head(model_df)
tail(model_df)
par(mfrow=c(1,1))
plot(model_df$int, model_df$int_true)
abline(0,1)
# Chunk 3
GE_true_means <- tapply(model_df$GE_true, model_df$GE_factor, mean)
model_df$GE_stn_true <- (model_df$GE_true - mean(GE_true_means))/sd(GE_true_means)
GE_stn_true_means <- tapply(model_df$GE_stn_true, model_df$GE_factor, mean)
G_stn_true <- data.frame(G=1:n_genotypes, G_stn_true=tapply(model_df$GE_stn_true, model_df$G, mean))
E_stn_true <- data.frame(E=1:n_genotypes , E_stn_true=tapply(model_df$GE_stn_true, model_df$E, mean))
model_df1 <- merge(model_df,G_stn_true)
model_df2 <- merge(model_df1,E_stn_true)
model_df <- model_df2
model_df$mean_stn_true <- mean(model_df$GE_stn_true)
model_df$int_stn_true <- model_df$mean_stn_true + model_df$GE_stn_true -
model_df$G_stn_true -   model_df$E_stn_true
head(model_df)
tail(model_df)
par(mfrow=c(1,1))
plot(model_df$int_true, model_df$int_stn_true)
# awesome
# Chunk 4
sd(GE_stn_true_means)
# I guess this will always be 1 because we standardize.
sd_noise <- sd(as.numeric(GE_stn_true_means))*scale
model_df$e = rnorm(n*n_genotypes*n_environments, 0, sd=sd_noise) # Random noise
model_df$phenotype <- model_df$GE_stn_true + model_df$e
head(model_df)
# Chunk 5
par(mfrow=c(1,1), mar=c(4,4,1,1))
plot(model_df$phenotype~model_df$E, col=0, xlim=c(1,n_genotypes+1), ylim=c(-3,3))
for (m in 1:n_genotypes){
x <- model_df$E[model_df$G==m]+0.05*(m-1)
points(model_df$phenotype[model_df$G==m]~x, col=m+1)
p_means <- tapply(model_df$phenotype[model_df$G==m],model_df$E[model_df$G==m], mean)
points(p_means~as.numeric(names(p_means)),
col=m+1, type="l")
}
# Chunk 6
# Step A: standardize by mean(GE_means) and sd(GE_means)
phen_GE_obs_means <- tapply(model_df$phenotype, model_df$GE_factor, mean)
plot(GE_stn_true_means, phen_GE_obs_means) #sanity check
abline(0,1)
model_df$phenotype_stn <- (model_df$phenotype-mean(phen_GE_obs_means))/sd(phen_GE_obs_means)
plot(model_df$phenotype, model_df$phenotype_stn)
abline(0,1)
# Step B: calculate observed G_means and E_means and interaction
G_stn_est <- data.frame(G=1:n_genotypes, G_stn_est=tapply(model_df$phenotype_stn, model_df$G, mean))
E_stn_est <- data.frame(E=1:n_genotypes , E_stn_est=tapply(model_df$phenotype_stn, model_df$E, mean))
GE_stn_est_means <- tapply(model_df$phenotype_stn, model_df$GE_factor, mean)
GE_stn_est_means_df <- data.frame(GE_factor=names(GE_stn_est_means) , GE_stn_est=GE_stn_est_means)
model_df1 <- merge(model_df,G_stn_est)
model_df2 <- merge(model_df1,E_stn_est)
model_df3 <- merge(model_df2, GE_stn_est_means_df)
model_df <- model_df3
plot(model_df$GE_stn_true, model_df$GE_stn_est)
abline(0,1) # looks good
model_df$mean_stn_est <- mean(model_df$phenotype_stn)
# Calculate interaction
model_df$int_stn_est <- model_df$mean_stn_est + model_df$GE_stn_est -
model_df$G_stn_est -   model_df$E_stn_est
# Chunk 7
head(model_df)
(true_int <- mean(abs(model_df$int_stn_true)))
(obs_int <- mean(abs(model_df$int_stn_est)))
head(model_df)
V_G_SS = sum((model_df$G_stn_est-model_df$mean_stn_est)^2)
V_E_SS = sum((model_df$E_stn_est-model_df$mean_stn_est)^2)
V_GE_SS = sum(model_df$int_stn_est^2)
V_error = sum((model_df$phenotype_stn - model_df$GE_stn_est)^2)
model_df$I = model_df$E==model_df$G
# Covariance pattern (ignore the 0,0 points)
par(mfrow=c(2,1))
plot(model_df$G_stn_est*model_df$I, model_df$E_stn_est*model_df$I)
plot(model_df$G_stn_est*model_df$I, model_df$E_stn_est*model_df$I, xlim=c(-1,1), ylim=c(-1,1))
V_Cov_GE <-  (nlevels(factor(model_df$G))-1)*
nlevels(factor(model_df$E))*
sum((model_df$G_stn_est-model_df$mean_stn_est)*(model_df$E_stn_est-model_df$mean_stn_est)*model_df$I)
SS <- round(rbind(V_G_SS, V_E_SS, V_GE_SS, V_Cov_GE, V_error),2)
omega2 <- round(abs(SS)/sum(abs(SS)),2)
data.frame(SS, abs(SS), omega2)
# Chunk 1: setup
knitr::opts_chunk$set(echo = TRUE)
library("emmeans")
library("lme4")
library("rlist")
library("dplyr")
# Chunk 2
beta1 = 10 # the amount the phenotype changes across 1 value of the environment (i.e., the slope). This is essentially the amount/degree of phenotypic plasticity that is the same across genotypes.
n_genotypes = 10 # the number of genotypes collected from different locations
n = 10 # sample size
beta2 = 10 # the amount the phenotype changes from one genotype to the next. This is essitially the increase intercept from one genotype to the next.
scale = 0.01 # the scale for sd_noise within pops compared to sd_means among pops
# I'll let you explore the space, but I think the upper would be scale = 1
# I'd start with scale = 1 and scale = 1/2 and see what that looks like
sd_int = 0#n_genotypes # sd of the interaction terms that will be drawn
#  beta1 <- 1
#  beta2 <- 1
# Generate data
n_environments = n_genotypes # the number of common garden environments that the genotypes are grown in. Basically, genotype[i] orginates from environment[i]. This matching between genotypes and environment is important for the the cov(G,E) calculation. Here, we only consider the case of the complete reciprocal transplant experiment.
## Create levels of genotypes and environments ####
G = rep(1:n_genotypes, each=n*n_genotypes) # '0' n times, '1' n times
E = rep(1:n_environments,times=n*n_genotypes) # '0'x50, '1'x50, '0'x50, '1'x50
#set.seed(97)
## Create interaction effect for each level of both factors ####
# In this case we assume the GxE interactions are a
# normally distributed random variable with a mean of 0
# As the sd increases, so does the GxE among treatments
if(sd_int == 0){
int = 0
}else{
int <- rnorm(n_genotypes * n_environments, 0, sd=sd_int)
}
# no GxE
# this sd determines the amount of GxE
int_df <- data.frame(expand.grid(G=1:n_genotypes, E=1:n_environments),
int)
### Create the model dataframe ####
model_df <- data.frame(G, E)
model_df$GE_factor <- paste0("G",model_df$G, "E", model_df$E)
model_df <- merge(model_df, int_df)
model_df <- model_df[order(model_df$G, model_df$E),]
dim(model_df)
head(model_df, 30)
# Generate phenotype data using the regression equation ####
model_df$GE_true = beta1*model_df$E + beta2*model_df$G + model_df$int
G_true <- data.frame(G=1:n_genotypes, G_true=tapply(model_df$GE_true, model_df$G, mean))
E_true <- data.frame(E=1:n_genotypes , E_true=tapply(model_df$GE_true, model_df$E, mean))
model_df1 <- merge(model_df,G_true)
model_df2 <- merge(model_df1,E_true)
model_df <- model_df2
model_df$mean_true <- mean(model_df$GE_true)
model_df$int_true <- model_df$mean_true + model_df$GE_true -
model_df$G_true -   model_df$E_true
head(model_df)
tail(model_df)
par(mfrow=c(1,1))
plot(model_df$int, model_df$int_true)
abline(0,1)
# Chunk 3
GE_true_means <- tapply(model_df$GE_true, model_df$GE_factor, mean)
model_df$GE_stn_true <- (model_df$GE_true - mean(GE_true_means))/sd(GE_true_means)
GE_stn_true_means <- tapply(model_df$GE_stn_true, model_df$GE_factor, mean)
G_stn_true <- data.frame(G=1:n_genotypes, G_stn_true=tapply(model_df$GE_stn_true, model_df$G, mean))
E_stn_true <- data.frame(E=1:n_genotypes , E_stn_true=tapply(model_df$GE_stn_true, model_df$E, mean))
model_df1 <- merge(model_df,G_stn_true)
model_df2 <- merge(model_df1,E_stn_true)
model_df <- model_df2
model_df$mean_stn_true <- mean(model_df$GE_stn_true)
model_df$int_stn_true <- model_df$mean_stn_true + model_df$GE_stn_true -
model_df$G_stn_true -   model_df$E_stn_true
head(model_df)
tail(model_df)
par(mfrow=c(1,1))
plot(model_df$int_true, model_df$int_stn_true)
# awesome
# Chunk 4
sd(GE_stn_true_means)
# I guess this will always be 1 because we standardize.
sd_noise <- sd(as.numeric(GE_stn_true_means))*scale
model_df$e = rnorm(n*n_genotypes*n_environments, 0, sd=sd_noise) # Random noise
model_df$phenotype <- model_df$GE_stn_true + model_df$e
head(model_df)
# Chunk 5
par(mfrow=c(1,1), mar=c(4,4,1,1))
plot(model_df$phenotype~model_df$E, col=0, xlim=c(1,n_genotypes+1), ylim=c(-3,3))
for (m in 1:n_genotypes){
x <- model_df$E[model_df$G==m]+0.05*(m-1)
points(model_df$phenotype[model_df$G==m]~x, col=m+1)
p_means <- tapply(model_df$phenotype[model_df$G==m],model_df$E[model_df$G==m], mean)
points(p_means~as.numeric(names(p_means)),
col=m+1, type="l")
}
# Chunk 6
# Step A: standardize by mean(GE_means) and sd(GE_means)
phen_GE_obs_means <- tapply(model_df$phenotype, model_df$GE_factor, mean)
plot(GE_stn_true_means, phen_GE_obs_means) #sanity check
abline(0,1)
model_df$phenotype_stn <- (model_df$phenotype-mean(phen_GE_obs_means))/sd(phen_GE_obs_means)
plot(model_df$phenotype, model_df$phenotype_stn)
abline(0,1)
# Step B: calculate observed G_means and E_means and interaction
G_stn_est <- data.frame(G=1:n_genotypes, G_stn_est=tapply(model_df$phenotype_stn, model_df$G, mean))
E_stn_est <- data.frame(E=1:n_genotypes , E_stn_est=tapply(model_df$phenotype_stn, model_df$E, mean))
GE_stn_est_means <- tapply(model_df$phenotype_stn, model_df$GE_factor, mean)
GE_stn_est_means_df <- data.frame(GE_factor=names(GE_stn_est_means) , GE_stn_est=GE_stn_est_means)
model_df1 <- merge(model_df,G_stn_est)
model_df2 <- merge(model_df1,E_stn_est)
model_df3 <- merge(model_df2, GE_stn_est_means_df)
model_df <- model_df3
plot(model_df$GE_stn_true, model_df$GE_stn_est)
abline(0,1) # looks good
model_df$mean_stn_est <- mean(model_df$phenotype_stn)
# Calculate interaction
model_df$int_stn_est <- model_df$mean_stn_est + model_df$GE_stn_est -
model_df$G_stn_est -   model_df$E_stn_est
# Chunk 7
head(model_df)
(true_int <- mean(abs(model_df$int_stn_true)))
(obs_int <- mean(abs(model_df$int_stn_est)))
model_df$Is
model_df$I
head(model_df)
V_G_SS = sum((model_df$G_stn_est-model_df$mean_stn_est)^2)
V_E_SS = sum((model_df$E_stn_est-model_df$mean_stn_est)^2)
V_GE_SS = sum(model_df$int_stn_est^2)
V_error = sum((model_df$phenotype_stn - model_df$GE_stn_est)^2)
model_df$I = model_df$E==model_df$G
# Covariance pattern (ignore the 0,0 points)
par(mfrow=c(2,1))
plot(model_df$G_stn_est*model_df$I, model_df$E_stn_est*model_df$I)
plot(model_df$G_stn_est*model_df$I, model_df$E_stn_est*model_df$I, xlim=c(-1,1), ylim=c(-1,1))
V_Cov_GE <-  *
sum((model_df$G_stn_est-model_df$mean_stn_est)*(model_df$E_stn_est-model_df$mean_stn_est)*model_df$I)
sum(model_df$I)
nrow(model_df)
head(model_df)
V_G_SS = sum((model_df$G_stn_est-model_df$mean_stn_est)^2)
V_E_SS = sum((model_df$E_stn_est-model_df$mean_stn_est)^2)
V_GE_SS = sum(model_df$int_stn_est^2)
V_error = sum((model_df$phenotype_stn - model_df$GE_stn_est)^2)
model_df$I = model_df$E==model_df$G
# Covariance pattern (ignore the 0,0 points)
par(mfrow=c(2,1))
plot(model_df$G_stn_est*model_df$I, model_df$E_stn_est*model_df$I)
plot(model_df$G_stn_est*model_df$I, model_df$E_stn_est*model_df$I, xlim=c(-1,1), ylim=c(-1,1))
V_Cov_GE <-  nrow(model_df)/sum(model_df$I)
sum((model_df$G_stn_est-model_df$mean_stn_est)*(model_df$E_stn_est-model_df$mean_stn_est)*model_df$I)
SS <- round(rbind(V_G_SS, V_E_SS, V_GE_SS, V_Cov_GE, V_error),2)
omega2 <- round(abs(SS)/sum(abs(SS)),2)
data.frame(SS, abs(SS), omega2)
# Covariance pattern (ignore the 0,0 points)
par(mfrow=c(2,1))
plot(model_df$G_stn_est*model_df$I, model_df$E_stn_est*model_df$I)
plot(model_df$G_stn_est*model_df$I, model_df$E_stn_est*model_df$I, xlim=c(-1,1), ylim=c(-1,1))
sum((model_df$G_stn_est-model_df$mean_stn_est)*(model_df$E_stn_est-model_df$mean_stn_est)*model_df$I)
nrow(model_df)
sum(model_df$I)
V_Cov_GE <-  nrow(model_df)/sum(model_df$I)*
sum((model_df$G_stn_est-model_df$mean_stn_est)*(model_df$E_stn_est-model_df$mean_stn_est)*model_df$I)
SS <- round(rbind(V_G_SS, V_E_SS, V_GE_SS, V_Cov_GE, V_error),2)
omega2 <- round(abs(SS)/sum(abs(SS)),2)
data.frame(SS, abs(SS), omega2)
# Chunk 1: setup
knitr::opts_chunk$set(echo = TRUE)
library("emmeans")
library("lme4")
library("rlist")
library("dplyr")
# Chunk 2
beta1 = 1 # the amount the phenotype changes across 1 value of the environment (i.e., the slope). This is essentially the amount/degree of phenotypic plasticity that is the same across genotypes.
n_genotypes = 10 # the number of genotypes collected from different locations
n = 10 # sample size
beta2 = 1 # the amount the phenotype changes from one genotype to the next. This is essitially the increase intercept from one genotype to the next.
scale = 0.01 # the scale for sd_noise within pops compared to sd_means among pops
# I'll let you explore the space, but I think the upper would be scale = 1
# I'd start with scale = 1 and scale = 1/2 and see what that looks like
sd_int = 0#n_genotypes # sd of the interaction terms that will be drawn
#  beta1 <- 1
#  beta2 <- 1
# Generate data
n_environments = n_genotypes # the number of common garden environments that the genotypes are grown in. Basically, genotype[i] orginates from environment[i]. This matching between genotypes and environment is important for the the cov(G,E) calculation. Here, we only consider the case of the complete reciprocal transplant experiment.
## Create levels of genotypes and environments ####
G = rep(1:n_genotypes, each=n*n_genotypes) # '0' n times, '1' n times
E = rep(1:n_environments,times=n*n_genotypes) # '0'x50, '1'x50, '0'x50, '1'x50
#set.seed(97)
## Create interaction effect for each level of both factors ####
# In this case we assume the GxE interactions are a
# normally distributed random variable with a mean of 0
# As the sd increases, so does the GxE among treatments
if(sd_int == 0){
int = 0
}else{
int <- rnorm(n_genotypes * n_environments, 0, sd=sd_int)
}
# no GxE
# this sd determines the amount of GxE
int_df <- data.frame(expand.grid(G=1:n_genotypes, E=1:n_environments),
int)
### Create the model dataframe ####
model_df <- data.frame(G, E)
model_df$GE_factor <- paste0("G",model_df$G, "E", model_df$E)
model_df <- merge(model_df, int_df)
model_df <- model_df[order(model_df$G, model_df$E),]
dim(model_df)
head(model_df, 30)
# Generate phenotype data using the regression equation ####
model_df$GE_true = beta1*model_df$E + beta2*model_df$G + model_df$int
G_true <- data.frame(G=1:n_genotypes, G_true=tapply(model_df$GE_true, model_df$G, mean))
E_true <- data.frame(E=1:n_genotypes , E_true=tapply(model_df$GE_true, model_df$E, mean))
model_df1 <- merge(model_df,G_true)
model_df2 <- merge(model_df1,E_true)
model_df <- model_df2
model_df$mean_true <- mean(model_df$GE_true)
model_df$int_true <- model_df$mean_true + model_df$GE_true -
model_df$G_true -   model_df$E_true
head(model_df)
tail(model_df)
par(mfrow=c(1,1))
plot(model_df$int, model_df$int_true)
abline(0,1)
# Chunk 3
GE_true_means <- tapply(model_df$GE_true, model_df$GE_factor, mean)
model_df$GE_stn_true <- (model_df$GE_true - mean(GE_true_means))/sd(GE_true_means)
GE_stn_true_means <- tapply(model_df$GE_stn_true, model_df$GE_factor, mean)
G_stn_true <- data.frame(G=1:n_genotypes, G_stn_true=tapply(model_df$GE_stn_true, model_df$G, mean))
E_stn_true <- data.frame(E=1:n_genotypes , E_stn_true=tapply(model_df$GE_stn_true, model_df$E, mean))
model_df1 <- merge(model_df,G_stn_true)
model_df2 <- merge(model_df1,E_stn_true)
model_df <- model_df2
model_df$mean_stn_true <- mean(model_df$GE_stn_true)
model_df$int_stn_true <- model_df$mean_stn_true + model_df$GE_stn_true -
model_df$G_stn_true -   model_df$E_stn_true
head(model_df)
tail(model_df)
par(mfrow=c(1,1))
plot(model_df$int_true, model_df$int_stn_true)
# awesome
# Chunk 4
sd(GE_stn_true_means)
# I guess this will always be 1 because we standardize.
sd_noise <- sd(as.numeric(GE_stn_true_means))*scale
model_df$e = rnorm(n*n_genotypes*n_environments, 0, sd=sd_noise) # Random noise
model_df$phenotype <- model_df$GE_stn_true + model_df$e
head(model_df)
# Chunk 5
par(mfrow=c(1,1), mar=c(4,4,1,1))
plot(model_df$phenotype~model_df$E, col=0, xlim=c(1,n_genotypes+1), ylim=c(-3,3))
for (m in 1:n_genotypes){
x <- model_df$E[model_df$G==m]+0.05*(m-1)
points(model_df$phenotype[model_df$G==m]~x, col=m+1)
p_means <- tapply(model_df$phenotype[model_df$G==m],model_df$E[model_df$G==m], mean)
points(p_means~as.numeric(names(p_means)),
col=m+1, type="l")
}
# Chunk 6
# Step A: standardize by mean(GE_means) and sd(GE_means)
phen_GE_obs_means <- tapply(model_df$phenotype, model_df$GE_factor, mean)
plot(GE_stn_true_means, phen_GE_obs_means) #sanity check
abline(0,1)
model_df$phenotype_stn <- (model_df$phenotype-mean(phen_GE_obs_means))/sd(phen_GE_obs_means)
plot(model_df$phenotype, model_df$phenotype_stn)
abline(0,1)
# Step B: calculate observed G_means and E_means and interaction
G_stn_est <- data.frame(G=1:n_genotypes, G_stn_est=tapply(model_df$phenotype_stn, model_df$G, mean))
E_stn_est <- data.frame(E=1:n_genotypes , E_stn_est=tapply(model_df$phenotype_stn, model_df$E, mean))
GE_stn_est_means <- tapply(model_df$phenotype_stn, model_df$GE_factor, mean)
GE_stn_est_means_df <- data.frame(GE_factor=names(GE_stn_est_means) , GE_stn_est=GE_stn_est_means)
model_df1 <- merge(model_df,G_stn_est)
model_df2 <- merge(model_df1,E_stn_est)
model_df3 <- merge(model_df2, GE_stn_est_means_df)
model_df <- model_df3
plot(model_df$GE_stn_true, model_df$GE_stn_est)
abline(0,1) # looks good
model_df$mean_stn_est <- mean(model_df$phenotype_stn)
# Calculate interaction
model_df$int_stn_est <- model_df$mean_stn_est + model_df$GE_stn_est -
model_df$G_stn_est -   model_df$E_stn_est
# Chunk 7
head(model_df)
(true_int <- mean(abs(model_df$int_stn_true)))
(obs_int <- mean(abs(model_df$int_stn_est)))
head(model_df)
V_G_SS = sum((model_df$G_stn_est-model_df$mean_stn_est)^2)
V_E_SS = sum((model_df$E_stn_est-model_df$mean_stn_est)^2)
V_GE_SS = sum(model_df$int_stn_est^2)
V_error = sum((model_df$phenotype_stn - model_df$GE_stn_est)^2)
model_df$I = model_df$E==model_df$G
# Covariance pattern (ignore the 0,0 points)
par(mfrow=c(2,1))
plot(model_df$G_stn_est*model_df$I, model_df$E_stn_est*model_df$I)
plot(model_df$G_stn_est*model_df$I, model_df$E_stn_est*model_df$I, xlim=c(-1,1), ylim=c(-1,1))
V_Cov_GE <-  nrow(model_df)/sum(model_df$I)*
sum((model_df$G_stn_est-model_df$mean_stn_est)*(model_df$E_stn_est-model_df$mean_stn_est)*model_df$I)
SS <- round(rbind(V_G_SS, V_E_SS, V_GE_SS, V_Cov_GE, V_error),2)
omega2 <- round(abs(SS)/sum(abs(SS)),2)
data.frame(SS, abs(SS), omega2)
# Chunk 1: setup
knitr::opts_chunk$set(echo = TRUE)
library("emmeans")
library("lme4")
library("rlist")
library("dplyr")
# Chunk 2
beta1 = -1 # the amount the phenotype changes across 1 value of the environment (i.e., the slope). This is essentially the amount/degree of phenotypic plasticity that is the same across genotypes.
n_genotypes = 10 # the number of genotypes collected from different locations
n = 10 # sample size
beta2 = 1 # the amount the phenotype changes from one genotype to the next. This is essitially the increase intercept from one genotype to the next.
scale = 0.01 # the scale for sd_noise within pops compared to sd_means among pops
# I'll let you explore the space, but I think the upper would be scale = 1
# I'd start with scale = 1 and scale = 1/2 and see what that looks like
sd_int = 0#n_genotypes # sd of the interaction terms that will be drawn
#  beta1 <- 1
#  beta2 <- 1
# Generate data
n_environments = n_genotypes # the number of common garden environments that the genotypes are grown in. Basically, genotype[i] orginates from environment[i]. This matching between genotypes and environment is important for the the cov(G,E) calculation. Here, we only consider the case of the complete reciprocal transplant experiment.
## Create levels of genotypes and environments ####
G = rep(1:n_genotypes, each=n*n_genotypes) # '0' n times, '1' n times
E = rep(1:n_environments,times=n*n_genotypes) # '0'x50, '1'x50, '0'x50, '1'x50
#set.seed(97)
## Create interaction effect for each level of both factors ####
# In this case we assume the GxE interactions are a
# normally distributed random variable with a mean of 0
# As the sd increases, so does the GxE among treatments
if(sd_int == 0){
int = 0
}else{
int <- rnorm(n_genotypes * n_environments, 0, sd=sd_int)
}
# no GxE
# this sd determines the amount of GxE
int_df <- data.frame(expand.grid(G=1:n_genotypes, E=1:n_environments),
int)
### Create the model dataframe ####
model_df <- data.frame(G, E)
model_df$GE_factor <- paste0("G",model_df$G, "E", model_df$E)
model_df <- merge(model_df, int_df)
model_df <- model_df[order(model_df$G, model_df$E),]
dim(model_df)
head(model_df, 30)
# Generate phenotype data using the regression equation ####
model_df$GE_true = beta1*model_df$E + beta2*model_df$G + model_df$int
G_true <- data.frame(G=1:n_genotypes, G_true=tapply(model_df$GE_true, model_df$G, mean))
E_true <- data.frame(E=1:n_genotypes , E_true=tapply(model_df$GE_true, model_df$E, mean))
model_df1 <- merge(model_df,G_true)
model_df2 <- merge(model_df1,E_true)
model_df <- model_df2
model_df$mean_true <- mean(model_df$GE_true)
model_df$int_true <- model_df$mean_true + model_df$GE_true -
model_df$G_true -   model_df$E_true
head(model_df)
tail(model_df)
par(mfrow=c(1,1))
plot(model_df$int, model_df$int_true)
abline(0,1)
# Chunk 3
GE_true_means <- tapply(model_df$GE_true, model_df$GE_factor, mean)
model_df$GE_stn_true <- (model_df$GE_true - mean(GE_true_means))/sd(GE_true_means)
GE_stn_true_means <- tapply(model_df$GE_stn_true, model_df$GE_factor, mean)
G_stn_true <- data.frame(G=1:n_genotypes, G_stn_true=tapply(model_df$GE_stn_true, model_df$G, mean))
E_stn_true <- data.frame(E=1:n_genotypes , E_stn_true=tapply(model_df$GE_stn_true, model_df$E, mean))
model_df1 <- merge(model_df,G_stn_true)
model_df2 <- merge(model_df1,E_stn_true)
model_df <- model_df2
model_df$mean_stn_true <- mean(model_df$GE_stn_true)
model_df$int_stn_true <- model_df$mean_stn_true + model_df$GE_stn_true -
model_df$G_stn_true -   model_df$E_stn_true
head(model_df)
tail(model_df)
par(mfrow=c(1,1))
plot(model_df$int_true, model_df$int_stn_true)
# awesome
# Chunk 4
sd(GE_stn_true_means)
# I guess this will always be 1 because we standardize.
sd_noise <- sd(as.numeric(GE_stn_true_means))*scale
model_df$e = rnorm(n*n_genotypes*n_environments, 0, sd=sd_noise) # Random noise
model_df$phenotype <- model_df$GE_stn_true + model_df$e
head(model_df)
# Chunk 5
par(mfrow=c(1,1), mar=c(4,4,1,1))
plot(model_df$phenotype~model_df$E, col=0, xlim=c(1,n_genotypes+1), ylim=c(-3,3))
for (m in 1:n_genotypes){
x <- model_df$E[model_df$G==m]+0.05*(m-1)
points(model_df$phenotype[model_df$G==m]~x, col=m+1)
p_means <- tapply(model_df$phenotype[model_df$G==m],model_df$E[model_df$G==m], mean)
points(p_means~as.numeric(names(p_means)),
col=m+1, type="l")
}
# Chunk 6
# Step A: standardize by mean(GE_means) and sd(GE_means)
phen_GE_obs_means <- tapply(model_df$phenotype, model_df$GE_factor, mean)
plot(GE_stn_true_means, phen_GE_obs_means) #sanity check
abline(0,1)
model_df$phenotype_stn <- (model_df$phenotype-mean(phen_GE_obs_means))/sd(phen_GE_obs_means)
plot(model_df$phenotype, model_df$phenotype_stn)
abline(0,1)
# Step B: calculate observed G_means and E_means and interaction
G_stn_est <- data.frame(G=1:n_genotypes, G_stn_est=tapply(model_df$phenotype_stn, model_df$G, mean))
E_stn_est <- data.frame(E=1:n_genotypes , E_stn_est=tapply(model_df$phenotype_stn, model_df$E, mean))
GE_stn_est_means <- tapply(model_df$phenotype_stn, model_df$GE_factor, mean)
GE_stn_est_means_df <- data.frame(GE_factor=names(GE_stn_est_means) , GE_stn_est=GE_stn_est_means)
model_df1 <- merge(model_df,G_stn_est)
model_df2 <- merge(model_df1,E_stn_est)
model_df3 <- merge(model_df2, GE_stn_est_means_df)
model_df <- model_df3
plot(model_df$GE_stn_true, model_df$GE_stn_est)
abline(0,1) # looks good
model_df$mean_stn_est <- mean(model_df$phenotype_stn)
# Calculate interaction
model_df$int_stn_est <- model_df$mean_stn_est + model_df$GE_stn_est -
model_df$G_stn_est -   model_df$E_stn_est
# Chunk 7
head(model_df)
(true_int <- mean(abs(model_df$int_stn_true)))
(obs_int <- mean(abs(model_df$int_stn_est)))
head(model_df)
V_G_SS = sum((model_df$G_stn_est-model_df$mean_stn_est)^2)
V_E_SS = sum((model_df$E_stn_est-model_df$mean_stn_est)^2)
V_GE_SS = sum(model_df$int_stn_est^2)
V_error = sum((model_df$phenotype_stn - model_df$GE_stn_est)^2)
model_df$I = model_df$E==model_df$G
# Covariance pattern (ignore the 0,0 points)
par(mfrow=c(2,1))
plot(model_df$G_stn_est*model_df$I, model_df$E_stn_est*model_df$I)
plot(model_df$G_stn_est*model_df$I, model_df$E_stn_est*model_df$I, xlim=c(-1,1), ylim=c(-1,1))
V_Cov_GE <-  nrow(model_df)/sum(model_df$I)*
sum((model_df$G_stn_est-model_df$mean_stn_est)*(model_df$E_stn_est-model_df$mean_stn_est)*model_df$I)
SS <- round(rbind(V_G_SS, V_E_SS, V_GE_SS, V_Cov_GE, V_error),2)
omega2 <- round(abs(SS)/sum(abs(SS)),2)
data.frame(SS, abs(SS), omega2)
