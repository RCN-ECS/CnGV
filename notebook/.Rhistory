n_environments = n_genotypes # the number of common garden environments that the genotypes are grown in. Basically, genotype[i] orginates from environment[i]. This matching between genotypes and environment is important for the the cov(G,E) calculation. Here, we only consider the case of the complete reciprocal transplant experiment.
## Create levels of genotypes and environments ####
G = rep(1:n_genotypes, each=n*n_genotypes) # '0' n times, '1' n times
E = rep(1:n_environments,times=n*n_genotypes) # '0'x50, '1'x50, '0'x50, '1'x50
set.seed(97)
e = rnorm(n*n_genotypes, 0, sd=0.01) # Random noise, with standard deviation of 1
#e = 0 # EVALUATION
## Create interaction effect for each level of both factors ####
# In this case we assume the GxE interactions are a
# normally distributed random variable with a mean of 0
# As the sd increases, so does the GxE among treatments
int <- 0#rnorm(n_genotypes * n_environments, 0, sd=10)
#int <- 0 # EVALUATION
# this sd determines the amount of GxE
int_df <- data.frame(expand.grid(G=1:n_genotypes, E=1:n_environments),
int)
### Create the model dataframe ####
model_df <- data.frame(G, E, e)
model_df <- merge(model_df, int_df)
model_df <- model_df[order(model_df$G, model_df$E),]
dim(model_df)
head(model_df, 30)
# Generate phenotype data using the regression equation ####
phenotype = beta1*model_df$E + beta2*model_df$G  + model_df$e + model_df$int
model_df$phenotype = phenotype
head(model_df)
(E_means <- tapply(phenotype, model_df$E, mean))
(G_means <- tapply(phenotype, model_df$G, mean))
cov(E_means, G_means)
cor(E_means, G_means)
# this should match the "true cov for raw data" I put above
# but the issue is we standardize the phenotype. So what happens when we do that?
phenotype_stn = (phenotype-mean(phenotype))/sd(phenotype)
(E_means_stn <- tapply(phenotype_stn, model_df$E, mean))
(G_means_stn <- tapply(phenotype_stn, model_df$G, mean))
plot(E_means_stn, G_means_stn)
cov(E_means_stn, G_means_stn)
cor(E_means_stn, G_means_stn)
plot(phenotype~model_df$E, col=model_df$G+1)
beta1 = 1 # the amount the phenotype changes across 1 value of the environment (i.e., the slope). This is essentially the amount/degree of phenotypic plasticity that is the same across genotypes.
n_genotypes = 9 # the number of genotypes collected from different locations
beta2 = -1 # the amount the phenotype changes from one genotype to the next. This is essitially the increase intercept from one genotype to the next.
# Check #1
(E_real <- 1:n_genotypes)
(G_real <- (0:(n_genotypes-1))*beta2)
(cov_GE = cov(E_real, G_real))  # true cov for raw data
(cor_GE = cor(E_real, G_real))
# old approximation
(cov_GE_approx = beta1 * beta2)
# will be correlated with the magnitude of cov(G,E)
# SANITY CHECK
# IF WE DO A RECIPROCAL TRANSPLANT WITH 10 Locations and
# 15 samples per location, we should get:
# 10 genotypes x 10 locations = 100 treatments x 15 samples = 1500 measurements
# The old code had a bug, in that it was only generating the correct data
# for the 2 population case, and not for cases with more than 2 populations
# Generate data
n = 15 # sample size
n_environments = n_genotypes # the number of common garden environments that the genotypes are grown in. Basically, genotype[i] orginates from environment[i]. This matching between genotypes and environment is important for the the cov(G,E) calculation. Here, we only consider the case of the complete reciprocal transplant experiment.
## Create levels of genotypes and environments ####
G = rep(1:n_genotypes, each=n*n_genotypes) # '0' n times, '1' n times
E = rep(1:n_environments,times=n*n_genotypes) # '0'x50, '1'x50, '0'x50, '1'x50
set.seed(97)
e = rnorm(n*n_genotypes, 0, sd=0.01) # Random noise, with standard deviation of 1
#e = 0 # EVALUATION
## Create interaction effect for each level of both factors ####
# In this case we assume the GxE interactions are a
# normally distributed random variable with a mean of 0
# As the sd increases, so does the GxE among treatments
int <- 0#rnorm(n_genotypes * n_environments, 0, sd=10)
#int <- 0 # EVALUATION
# this sd determines the amount of GxE
int_df <- data.frame(expand.grid(G=1:n_genotypes, E=1:n_environments),
int)
### Create the model dataframe ####
model_df <- data.frame(G, E, e)
model_df <- merge(model_df, int_df)
model_df <- model_df[order(model_df$G, model_df$E),]
dim(model_df)
head(model_df, 30)
# Generate phenotype data using the regression equation ####
phenotype = beta1*model_df$E + beta2*model_df$G  + model_df$e + model_df$int
model_df$phenotype = phenotype
head(model_df)
(E_means <- tapply(phenotype, model_df$E, mean))
(G_means <- tapply(phenotype, model_df$G, mean))
cov(E_means, G_means)
cor(E_means, G_means)
# this should match the "true cov for raw data" I put above
# but the issue is we standardize the phenotype. So what happens when we do that?
phenotype_stn = (phenotype-mean(phenotype))/sd(phenotype)
(E_means_stn <- tapply(phenotype_stn, model_df$E, mean))
(G_means_stn <- tapply(phenotype_stn, model_df$G, mean))
plot(E_means_stn, G_means_stn)
cov(E_means_stn, G_means_stn)
cor(E_means_stn, G_means_stn)
plot(phenotype~model_df$E, col=model_df$G+1)
beta1 = 1 # the amount the phenotype changes across 1 value of the environment (i.e., the slope). This is essentially the amount/degree of phenotypic plasticity that is the same across genotypes.
n_genotypes = 8 # the number of genotypes collected from different locations
beta2 = -1 # the amount the phenotype changes from one genotype to the next. This is essitially the increase intercept from one genotype to the next.
# Check #1
(E_real <- 1:n_genotypes)
(G_real <- (0:(n_genotypes-1))*beta2)
(cov_GE = cov(E_real, G_real))  # true cov for raw data
(cor_GE = cor(E_real, G_real))
# old approximation
(cov_GE_approx = beta1 * beta2)
# will be correlated with the magnitude of cov(G,E)
# SANITY CHECK
# IF WE DO A RECIPROCAL TRANSPLANT WITH 10 Locations and
# 15 samples per location, we should get:
# 10 genotypes x 10 locations = 100 treatments x 15 samples = 1500 measurements
# The old code had a bug, in that it was only generating the correct data
# for the 2 population case, and not for cases with more than 2 populations
# Generate data
n = 15 # sample size
n_environments = n_genotypes # the number of common garden environments that the genotypes are grown in. Basically, genotype[i] orginates from environment[i]. This matching between genotypes and environment is important for the the cov(G,E) calculation. Here, we only consider the case of the complete reciprocal transplant experiment.
## Create levels of genotypes and environments ####
G = rep(1:n_genotypes, each=n*n_genotypes) # '0' n times, '1' n times
E = rep(1:n_environments,times=n*n_genotypes) # '0'x50, '1'x50, '0'x50, '1'x50
set.seed(97)
e = rnorm(n*n_genotypes, 0, sd=0.01) # Random noise, with standard deviation of 1
#e = 0 # EVALUATION
## Create interaction effect for each level of both factors ####
# In this case we assume the GxE interactions are a
# normally distributed random variable with a mean of 0
# As the sd increases, so does the GxE among treatments
int <- 0#rnorm(n_genotypes * n_environments, 0, sd=10)
#int <- 0 # EVALUATION
# this sd determines the amount of GxE
int_df <- data.frame(expand.grid(G=1:n_genotypes, E=1:n_environments),
int)
### Create the model dataframe ####
model_df <- data.frame(G, E, e)
model_df <- merge(model_df, int_df)
model_df <- model_df[order(model_df$G, model_df$E),]
dim(model_df)
head(model_df, 30)
# Generate phenotype data using the regression equation ####
phenotype = beta1*model_df$E + beta2*model_df$G  + model_df$e + model_df$int
model_df$phenotype = phenotype
head(model_df)
(E_means <- tapply(phenotype, model_df$E, mean))
(G_means <- tapply(phenotype, model_df$G, mean))
cov(E_means, G_means)
cor(E_means, G_means)
# this should match the "true cov for raw data" I put above
# but the issue is we standardize the phenotype. So what happens when we do that?
phenotype_stn = (phenotype-mean(phenotype))/sd(phenotype)
(E_means_stn <- tapply(phenotype_stn, model_df$E, mean))
(G_means_stn <- tapply(phenotype_stn, model_df$G, mean))
plot(E_means_stn, G_means_stn)
cov(E_means_stn, G_means_stn)
cor(E_means_stn, G_means_stn)
plot(phenotype~model_df$E, col=model_df$G+1)
beta1 = 1 # the amount the phenotype changes across 1 value of the environment (i.e., the slope). This is essentially the amount/degree of phenotypic plasticity that is the same across genotypes.
n_genotypes = 3 # the number of genotypes collected from different locations
beta2 = -1 # the amount the phenotype changes from one genotype to the next. This is essitially the increase intercept from one genotype to the next.
# Check #1
(E_real <- 1:n_genotypes)
(G_real <- (0:(n_genotypes-1))*beta2)
(cov_GE = cov(E_real, G_real))  # true cov for raw data
(cor_GE = cor(E_real, G_real))
# old approximation
(cov_GE_approx = beta1 * beta2)
# will be correlated with the magnitude of cov(G,E)
# SANITY CHECK
# IF WE DO A RECIPROCAL TRANSPLANT WITH 10 Locations and
# 15 samples per location, we should get:
# 10 genotypes x 10 locations = 100 treatments x 15 samples = 1500 measurements
# The old code had a bug, in that it was only generating the correct data
# for the 2 population case, and not for cases with more than 2 populations
# Generate data
n = 15 # sample size
n_environments = n_genotypes # the number of common garden environments that the genotypes are grown in. Basically, genotype[i] orginates from environment[i]. This matching between genotypes and environment is important for the the cov(G,E) calculation. Here, we only consider the case of the complete reciprocal transplant experiment.
## Create levels of genotypes and environments ####
G = rep(1:n_genotypes, each=n*n_genotypes) # '0' n times, '1' n times
E = rep(1:n_environments,times=n*n_genotypes) # '0'x50, '1'x50, '0'x50, '1'x50
set.seed(97)
e = rnorm(n*n_genotypes, 0, sd=0.01) # Random noise, with standard deviation of 1
#e = 0 # EVALUATION
## Create interaction effect for each level of both factors ####
# In this case we assume the GxE interactions are a
# normally distributed random variable with a mean of 0
# As the sd increases, so does the GxE among treatments
int <- 0#rnorm(n_genotypes * n_environments, 0, sd=10)
#int <- 0 # EVALUATION
# this sd determines the amount of GxE
int_df <- data.frame(expand.grid(G=1:n_genotypes, E=1:n_environments),
int)
### Create the model dataframe ####
model_df <- data.frame(G, E, e)
model_df <- merge(model_df, int_df)
model_df <- model_df[order(model_df$G, model_df$E),]
dim(model_df)
head(model_df, 30)
# Generate phenotype data using the regression equation ####
phenotype = beta1*model_df$E + beta2*model_df$G  + model_df$e + model_df$int
model_df$phenotype = phenotype
head(model_df)
(E_means <- tapply(phenotype, model_df$E, mean))
(G_means <- tapply(phenotype, model_df$G, mean))
cov(E_means, G_means)
cor(E_means, G_means)
# this should match the "true cov for raw data" I put above
# but the issue is we standardize the phenotype. So what happens when we do that?
phenotype_stn = (phenotype-mean(phenotype))/sd(phenotype)
(E_means_stn <- tapply(phenotype_stn, model_df$E, mean))
(G_means_stn <- tapply(phenotype_stn, model_df$G, mean))
plot(E_means_stn, G_means_stn)
cov(E_means_stn, G_means_stn)
cor(E_means_stn, G_means_stn)
plot(phenotype~model_df$E, col=model_df$G+1)
beta1 = 1 # the amount the phenotype changes across 1 value of the environment (i.e., the slope). This is essentially the amount/degree of phenotypic plasticity that is the same across genotypes.
n_genotypes = 3 # the number of genotypes collected from different locations
beta2 = -1 # the amount the phenotype changes from one genotype to the next. This is essitially the increase intercept from one genotype to the next.
# Check #1
(E_real <- 1:n_genotypes)
(G_real <- (0:(n_genotypes-1))*beta2)
(cov_GE = cov(E_real, G_real))  # true cov for raw data
(cor_GE = cor(E_real, G_real))
# old approximation
(cov_GE_approx = beta1 * beta2)
# will be correlated with the magnitude of cov(G,E)
# SANITY CHECK
# IF WE DO A RECIPROCAL TRANSPLANT WITH 10 Locations and
# 15 samples per location, we should get:
# 10 genotypes x 10 locations = 100 treatments x 15 samples = 1500 measurements
# The old code had a bug, in that it was only generating the correct data
# for the 2 population case, and not for cases with more than 2 populations
# Generate data
n = 15 # sample size
n_environments = n_genotypes # the number of common garden environments that the genotypes are grown in. Basically, genotype[i] orginates from environment[i]. This matching between genotypes and environment is important for the the cov(G,E) calculation. Here, we only consider the case of the complete reciprocal transplant experiment.
## Create levels of genotypes and environments ####
G = rep(1:n_genotypes, each=n*n_genotypes) # '0' n times, '1' n times
E = rep(1:n_environments,times=n*n_genotypes) # '0'x50, '1'x50, '0'x50, '1'x50
set.seed(97)
e = rnorm(n*n_genotypes, 0, sd=0.01) # Random noise, with standard deviation of 1
#e = 0 # EVALUATION
## Create interaction effect for each level of both factors ####
# In this case we assume the GxE interactions are a
# normally distributed random variable with a mean of 0
# As the sd increases, so does the GxE among treatments
int <- 0#rnorm(n_genotypes * n_environments, 0, sd=10)
#int <- 0 # EVALUATION
# this sd determines the amount of GxE
int_df <- data.frame(expand.grid(G=1:n_genotypes, E=1:n_environments),
int)
### Create the model dataframe ####
model_df <- data.frame(G, E, e)
model_df <- merge(model_df, int_df)
model_df <- model_df[order(model_df$G, model_df$E),]
dim(model_df)
head(model_df, 30)
# Generate phenotype data using the regression equation ####
phenotype = beta1*model_df$E + beta2*model_df$G  + model_df$e + model_df$int
model_df$phenotype = phenotype
head(model_df)
(E_means <- tapply(phenotype, model_df$E, mean))
(G_means <- tapply(phenotype, model_df$G, mean))
cov(E_means, G_means)
cor(E_means, G_means)
# this should match the "true cov for raw data" I put above
# but the issue is we standardize the phenotype. So what happens when we do that?
phenotype_stn = (phenotype-mean(phenotype))/sd(phenotype)
(E_means_stn <- tapply(phenotype_stn, model_df$E, mean))
(G_means_stn <- tapply(phenotype_stn, model_df$G, mean))
cov(E_means_stn, G_means_stn)
cor(E_means_stn, G_means_stn)
plot(phenotype~model_df$E, col=model_df$G+1)
plot(E_means_stn, G_means_stn)
beta1 = 1 # the amount the phenotype changes across 1 value of the environment (i.e., the slope). This is essentially the amount/degree of phenotypic plasticity that is the same across genotypes.
n_genotypes = 6 # the number of genotypes collected from different locations
beta2 = -1 # the amount the phenotype changes from one genotype to the next. This is essitially the increase intercept from one genotype to the next.
# Check #1
(E_real <- 1:n_genotypes)
(G_real <- (0:(n_genotypes-1))*beta2)
(cov_GE = cov(E_real, G_real))  # true cov for raw data
(cor_GE = cor(E_real, G_real))
# old approximation
(cov_GE_approx = beta1 * beta2)
# will be correlated with the magnitude of cov(G,E)
# SANITY CHECK
# IF WE DO A RECIPROCAL TRANSPLANT WITH 10 Locations and
# 15 samples per location, we should get:
# 10 genotypes x 10 locations = 100 treatments x 15 samples = 1500 measurements
# The old code had a bug, in that it was only generating the correct data
# for the 2 population case, and not for cases with more than 2 populations
# Generate data
n = 15 # sample size
n_environments = n_genotypes # the number of common garden environments that the genotypes are grown in. Basically, genotype[i] orginates from environment[i]. This matching between genotypes and environment is important for the the cov(G,E) calculation. Here, we only consider the case of the complete reciprocal transplant experiment.
## Create levels of genotypes and environments ####
G = rep(1:n_genotypes, each=n*n_genotypes) # '0' n times, '1' n times
E = rep(1:n_environments,times=n*n_genotypes) # '0'x50, '1'x50, '0'x50, '1'x50
set.seed(97)
e = rnorm(n*n_genotypes, 0, sd=0.01) # Random noise, with standard deviation of 1
#e = 0 # EVALUATION
## Create interaction effect for each level of both factors ####
# In this case we assume the GxE interactions are a
# normally distributed random variable with a mean of 0
# As the sd increases, so does the GxE among treatments
int <- 0#rnorm(n_genotypes * n_environments, 0, sd=10)
#int <- 0 # EVALUATION
# this sd determines the amount of GxE
int_df <- data.frame(expand.grid(G=1:n_genotypes, E=1:n_environments),
int)
### Create the model dataframe ####
model_df <- data.frame(G, E, e)
model_df <- merge(model_df, int_df)
model_df <- model_df[order(model_df$G, model_df$E),]
dim(model_df)
head(model_df, 30)
# Generate phenotype data using the regression equation ####
phenotype = beta1*model_df$E + beta2*model_df$G  + model_df$e + model_df$int
model_df$phenotype = phenotype
head(model_df)
(E_means <- tapply(phenotype, model_df$E, mean))
(G_means <- tapply(phenotype, model_df$G, mean))
cov(E_means, G_means)
cor(E_means, G_means)
# this should match the "true cov for raw data" I put above
# but the issue is we standardize the phenotype. So what happens when we do that?
phenotype_stn = (phenotype-mean(phenotype))/sd(phenotype)
(E_means_stn <- tapply(phenotype_stn, model_df$E, mean))
(G_means_stn <- tapply(phenotype_stn, model_df$G, mean))
cov(E_means_stn, G_means_stn)
cor(E_means_stn, G_means_stn)
plot(phenotype~model_df$E, col=model_df$G+1)
plot(E_means_stn, G_means_stn)
beta1 = 1 # the amount the phenotype changes across 1 value of the environment (i.e., the slope). This is essentially the amount/degree of phenotypic plasticity that is the same across genotypes.
n_genotypes = 8 # the number of genotypes collected from different locations
beta2 = -1 # the amount the phenotype changes from one genotype to the next. This is essitially the increase intercept from one genotype to the next.
# Check #1
(E_real <- 1:n_genotypes)
(G_real <- (0:(n_genotypes-1))*beta2)
(cov_GE = cov(E_real, G_real))  # true cov for raw data
(cor_GE = cor(E_real, G_real))
# old approximation
(cov_GE_approx = beta1 * beta2)
# will be correlated with the magnitude of cov(G,E)
# SANITY CHECK
# IF WE DO A RECIPROCAL TRANSPLANT WITH 10 Locations and
# 15 samples per location, we should get:
# 10 genotypes x 10 locations = 100 treatments x 15 samples = 1500 measurements
# The old code had a bug, in that it was only generating the correct data
# for the 2 population case, and not for cases with more than 2 populations
# Generate data
n = 15 # sample size
n_environments = n_genotypes # the number of common garden environments that the genotypes are grown in. Basically, genotype[i] orginates from environment[i]. This matching between genotypes and environment is important for the the cov(G,E) calculation. Here, we only consider the case of the complete reciprocal transplant experiment.
## Create levels of genotypes and environments ####
G = rep(1:n_genotypes, each=n*n_genotypes) # '0' n times, '1' n times
E = rep(1:n_environments,times=n*n_genotypes) # '0'x50, '1'x50, '0'x50, '1'x50
set.seed(97)
e = rnorm(n*n_genotypes, 0, sd=0.01) # Random noise, with standard deviation of 1
#e = 0 # EVALUATION
## Create interaction effect for each level of both factors ####
# In this case we assume the GxE interactions are a
# normally distributed random variable with a mean of 0
# As the sd increases, so does the GxE among treatments
int <- 0#rnorm(n_genotypes * n_environments, 0, sd=10)
#int <- 0 # EVALUATION
# this sd determines the amount of GxE
int_df <- data.frame(expand.grid(G=1:n_genotypes, E=1:n_environments),
int)
### Create the model dataframe ####
model_df <- data.frame(G, E, e)
model_df <- merge(model_df, int_df)
model_df <- model_df[order(model_df$G, model_df$E),]
dim(model_df)
head(model_df, 30)
# Generate phenotype data using the regression equation ####
phenotype = beta1*model_df$E + beta2*model_df$G  + model_df$e + model_df$int
model_df$phenotype = phenotype
head(model_df)
(E_means <- tapply(phenotype, model_df$E, mean))
(G_means <- tapply(phenotype, model_df$G, mean))
cov(E_means, G_means)
cor(E_means, G_means)
# this should match the "true cov for raw data" I put above
# but the issue is we standardize the phenotype. So what happens when we do that?
phenotype_stn = (phenotype-mean(phenotype))/sd(phenotype)
(E_means_stn <- tapply(phenotype_stn, model_df$E, mean))
(G_means_stn <- tapply(phenotype_stn, model_df$G, mean))
cov(E_means_stn, G_means_stn)
cor(E_means_stn, G_means_stn)
plot(phenotype~model_df$E, col=model_df$G+1)
plot(E_means_stn, G_means_stn)
beta1 = 1 # the amount the phenotype changes across 1 value of the environment (i.e., the slope). This is essentially the amount/degree of phenotypic plasticity that is the same across genotypes.
n_genotypes = 9 # the number of genotypes collected from different locations
beta2 = -1 # the amount the phenotype changes from one genotype to the next. This is essitially the increase intercept from one genotype to the next.
# Check #1
(E_real <- 1:n_genotypes)
(G_real <- (0:(n_genotypes-1))*beta2)
(cov_GE = cov(E_real, G_real))  # true cov for raw data
(cor_GE = cor(E_real, G_real))
# old approximation
(cov_GE_approx = beta1 * beta2)
# will be correlated with the magnitude of cov(G,E)
# SANITY CHECK
# IF WE DO A RECIPROCAL TRANSPLANT WITH 10 Locations and
# 15 samples per location, we should get:
# 10 genotypes x 10 locations = 100 treatments x 15 samples = 1500 measurements
# The old code had a bug, in that it was only generating the correct data
# for the 2 population case, and not for cases with more than 2 populations
# Generate data
n = 15 # sample size
n_environments = n_genotypes # the number of common garden environments that the genotypes are grown in. Basically, genotype[i] orginates from environment[i]. This matching between genotypes and environment is important for the the cov(G,E) calculation. Here, we only consider the case of the complete reciprocal transplant experiment.
## Create levels of genotypes and environments ####
G = rep(1:n_genotypes, each=n*n_genotypes) # '0' n times, '1' n times
E = rep(1:n_environments,times=n*n_genotypes) # '0'x50, '1'x50, '0'x50, '1'x50
set.seed(97)
e = rnorm(n*n_genotypes, 0, sd=0.01) # Random noise, with standard deviation of 1
#e = 0 # EVALUATION
## Create interaction effect for each level of both factors ####
# In this case we assume the GxE interactions are a
# normally distributed random variable with a mean of 0
# As the sd increases, so does the GxE among treatments
int <- 0#rnorm(n_genotypes * n_environments, 0, sd=10)
#int <- 0 # EVALUATION
# this sd determines the amount of GxE
int_df <- data.frame(expand.grid(G=1:n_genotypes, E=1:n_environments),
int)
### Create the model dataframe ####
model_df <- data.frame(G, E, e)
model_df <- merge(model_df, int_df)
model_df <- model_df[order(model_df$G, model_df$E),]
dim(model_df)
head(model_df, 30)
# Generate phenotype data using the regression equation ####
phenotype = beta1*model_df$E + beta2*model_df$G  + model_df$e + model_df$int
model_df$phenotype = phenotype
head(model_df)
(E_means <- tapply(phenotype, model_df$E, mean))
(G_means <- tapply(phenotype, model_df$G, mean))
cov(E_means, G_means)
cor(E_means, G_means)
# this should match the "true cov for raw data" I put above
# but the issue is we standardize the phenotype. So what happens when we do that?
phenotype_stn = (phenotype-mean(phenotype))/sd(phenotype)
(E_means_stn <- tapply(phenotype_stn, model_df$E, mean))
(G_means_stn <- tapply(phenotype_stn, model_df$G, mean))
cov(E_means_stn, G_means_stn)
cor(E_means_stn, G_means_stn)
plot(phenotype~model_df$E, col=model_df$G+1)
plot(E_means_stn, G_means_stn)
beta1 = 1 # the amount the phenotype changes across 1 value of the environment (i.e., the slope). This is essentially the amount/degree of phenotypic plasticity that is the same across genotypes.
n_genotypes = 100 # the number of genotypes collected from different locations
beta2 = -1 # the amount the phenotype changes from one genotype to the next. This is essitially the increase intercept from one genotype to the next.
# Check #1
(E_real <- 1:n_genotypes)
(G_real <- (0:(n_genotypes-1))*beta2)
(cov_GE = cov(E_real, G_real))  # true cov for raw data
(cor_GE = cor(E_real, G_real))
# old approximation
(cov_GE_approx = beta1 * beta2)
# will be correlated with the magnitude of cov(G,E)
# SANITY CHECK
# IF WE DO A RECIPROCAL TRANSPLANT WITH 10 Locations and
# 15 samples per location, we should get:
# 10 genotypes x 10 locations = 100 treatments x 15 samples = 1500 measurements
# The old code had a bug, in that it was only generating the correct data
# for the 2 population case, and not for cases with more than 2 populations
# Generate data
n = 15 # sample size
n_environments = n_genotypes # the number of common garden environments that the genotypes are grown in. Basically, genotype[i] orginates from environment[i]. This matching between genotypes and environment is important for the the cov(G,E) calculation. Here, we only consider the case of the complete reciprocal transplant experiment.
## Create levels of genotypes and environments ####
G = rep(1:n_genotypes, each=n*n_genotypes) # '0' n times, '1' n times
E = rep(1:n_environments,times=n*n_genotypes) # '0'x50, '1'x50, '0'x50, '1'x50
set.seed(97)
e = rnorm(n*n_genotypes, 0, sd=0.01) # Random noise, with standard deviation of 1
#e = 0 # EVALUATION
## Create interaction effect for each level of both factors ####
# In this case we assume the GxE interactions are a
# normally distributed random variable with a mean of 0
# As the sd increases, so does the GxE among treatments
int <- 0#rnorm(n_genotypes * n_environments, 0, sd=10)
#int <- 0 # EVALUATION
# this sd determines the amount of GxE
int_df <- data.frame(expand.grid(G=1:n_genotypes, E=1:n_environments),
int)
### Create the model dataframe ####
model_df <- data.frame(G, E, e)
model_df <- merge(model_df, int_df)
model_df <- model_df[order(model_df$G, model_df$E),]
dim(model_df)
head(model_df, 30)
# Generate phenotype data using the regression equation ####
phenotype = beta1*model_df$E + beta2*model_df$G  + model_df$e + model_df$int
model_df$phenotype = phenotype
head(model_df)
(E_means <- tapply(phenotype, model_df$E, mean))
(G_means <- tapply(phenotype, model_df$G, mean))
cov(E_means, G_means)
cor(E_means, G_means)
# this should match the "true cov for raw data" I put above
# but the issue is we standardize the phenotype. So what happens when we do that?
phenotype_stn = (phenotype-mean(phenotype))/sd(phenotype)
(E_means_stn <- tapply(phenotype_stn, model_df$E, mean))
(G_means_stn <- tapply(phenotype_stn, model_df$G, mean))
cov(E_means_stn, G_means_stn)
cor(E_means_stn, G_means_stn)
plot(phenotype~model_df$E, col=model_df$G+1)
plot(E_means_stn, G_means_stn)
(l1 = 9.3e(-10))
(l1 = 9.3e-10)
(lunf = 1.10e-08)
LRT = 1.10e-08/9.3e-10
(LRT = 1.10e-08/9.3e-10)
-2*ln(11.8)
-2*log(11.8)
(LRT = 9.3e-10/1.10e-08)
-2*log(LRT)
