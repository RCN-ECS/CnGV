# Fixes and Finesses

This post is in response to this [previous post](https://github.com/RCN-ECS/CnGV/blob/master/notebook/20201109_KEL_MA_meetingnotes.md) in which Molly went through a few lingering issues with the simulations. 

## Issue #1. GxE p-values 
The p-values for the raw data were alarmingly different from the p-values generated by the ANOVA, although some discrpancy is expected. One potential reason is that I was still testing the null that GxE = 0, not that GxE = G+E, like i had implemented with the means data. 
So I re-coded the null hypothesis for the raw data into the following: 

This also resolves one of the other issues which is to ensure that methods for means matches raw. I will triple check, but I am 99% sure this was the only "avoidable" methodological difference between means and raw. (I say avoidable because means requires sampling a new mean, whereas we do not need to do that for the raw data)

```{G+E permutation code}

 allGE <- NULL
    for (i in 1:nlevels(input_df$gen_factor)){
      for (j in 1:nlevels(input_df$exp_env_factor)){
        
        G_levels <- levels(input_df$gen_factor)
        E_levels <- levels(input_df$exp_env_factor)
        
        Gi_mean <- mean(sample(input_df$phen_corrected[input_df$gen_factor == G_levels[i]], 
                               size = length(input_df$phen_corrected[input_df$gen_factor == G_levels[i]]),
                               replace = TRUE))
        Ej_mean <- mean(sample(input_df$phen_corrected[input_df$exp_env_factor == E_levels[j]],
                               size = length(input_df$phen_corrected[input_df$exp_env_factor == E_levels[j]]),
                               replace = TRUE))
        GE_sd <- input_df %>%
          filter(gen_factor == G_levels[i]) %>%
          filter(exp_env_factor == E_levels[j]) %>%
          summarize("GEsd" = mean(e))

        # Create a sample of the null expectation for the Gi+Ej
        set.seed = seed
        GiEj_null_samp <- rnorm(1, mean = (Gi_mean + Ej_mean), sd = abs(GE_sd[[1]]))
        
        # Estimate 
        GxE_mean.temp <- abs(GiEj_null_samp - # G+E (Phenotype of ith genotype in jth environment)
                             Gi_mean - # mean phenotype of ith Genotype
                             Ej_mean + # mean phenotype of jth Environment
                             mean(input_df$phen_corrected)) # Overall mean
        allGE <- c(allGE, GxE_mean.temp)
      }
    }
    
    GxE_emm_loop = mean(allGE)
```

I ran a quick replicate (which wasn't at all quick, because I had to do a TON of debugging after making these changes... ) and now get the following for the GxE: (loess fits to total sample size visualize general patterns)
![image](https://github.com/RCN-ECS/CnGV/blob/master/results/notebook_figs/11.16.GxE_pvalueCompare.png)

Still not perfect, but a definite improvement relative to before. 

To double check that the issue was with permutation and not the way we calculate error, I again compare confidence intervals. The plots look okay to me. This probably means if a problem in p-value lingers, its likely in the way we're estimating p-values, not error.  
![image](https://github.com/RCN-ECS/CnGV/blob/master/results/notebook_figs/11.16.GxE_ConfIntervals.png)

## Issue #2: Population vs. Sample estimates. 
We identified an issue in our actual (i.e. population) vs. estimated (i.e., sample) covariance estimations. The function cov() in r is a sample estimator, and thus uses the denominator of n-1 to calculate covariance. 

I fixed this by creating my own manual function to calculate covariance for samples and for population level. I still keep the cov() as a sanity check, since my function should give the exact same Cov estimates for samples. New function below:  
```{function}
cov.function <- function(input_df, is.sample){ # input_df = cov_matrix of G_means and E_means
  N = length(input_df$gen_factor)
  overallmean = mean(c(input_df$G_means,input_df$E_means))
  numerator = sum((input_df$G_means - overallmean)*(input_df$E_means - overallmean))

  if(is.sample == TRUE){
    cv = (1/(N-1))*numerator
  }else{
    cv = (1/(N))*numerator
  }
  return(cv)
}
```
## Issue #3: Find the False Positives! 
And the false negatives, and the true negatives... 
I created these heatmaps to better delineate which designs are driving different error types to hone in our sampling a bit better. 

Top number is the percent (higher percent = condition found more frequently in that group), bottom number is total sample size. 

#### Raw data - Full Reciprocal Transplant 
| --- | Covariance | GxE |
|---|---|---|
|Bootstrap|![image](https://github.com/RCN-ECS/CnGV/blob/master/results/notebook_figs/11.17.CovBootHeat.png)|![image](https://github.com/RCN-ECS/CnGV/blob/master/results/notebook_figs/11.17.GxEBootHeat.png)|
|Permutation|![image](https://github.com/RCN-ECS/CnGV/blob/master/results/notebook_figs/11.17.CovPermHeat.png)|![image](https://github.com/RCN-ECS/CnGV/blob/master/results/notebook_figs/11.17.GxEPermHeat.png)|

#### Raw data - Paired Common Garden
| --- | Covariance | GxE |
|---|---|---|
|Bootstrap|![image](https://github.com/RCN-ECS/CnGV/blob/master/results/notebook_figs/11.16.CovBootHeat_dub.png)|![image](https://github.com/RCN-ECS/CnGV/blob/master/results/notebook_figs/11.16.gxebootHeat_dub.png)|
|Permutation|![image](https://github.com/RCN-ECS/CnGV/blob/master/results/notebook_figs/11.16.CovPermHeat_dub.png)|![image](https://github.com/RCN-ECS/CnGV/blob/master/results/notebook_figs/11.16.GxEPermHeat_dub.png)|
