---
title: "Multiple Populations for CnGv and GxE"
author: "KE Lotterhos"
date: "1/15/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

The purpose of this code is to provide a more general framework for modeling phenotypes in a reciprocal transplant experiment with more than two locations, when there is both GxE and cov(G,E) affecting the phenotype.

Basically, we model the phenotype as an additive function of:
- an intercept that is based on the location/environment the phenotype was collected from. Intercepts increase or decrease in a linear manner across the environment.
- a slope that determines the plastic response of the phenotype across the environment
- an interaction term that determines how the phenotype of genotype $i$ in environment $j$ deviates from the main effects
- random error or noise

**Below, I edited this previous post to show solutions for issues that were arising with simulating a reciprocal transplant with more than 2 genotypes. Basically we kept getting an issue where the maximum possible covariance was decreasing with increaseing number of reciprocal transplant sites. By changine `n_genotypes` in the code below, you can see the issue that arises after standardizing the phenotypic data to a mean of 0 and unit variance. I also show that a solution is to use cov(G,E) when n_genotypes = 2, and use cor(G, E) when n_genotypes > 2.**

```{r}
G <- -5:5
E <- -5:5
cov(G, E)

# If G and E are independent, then scaling each one independently essentially gives a correlation:
cov(scale(G), scale(E))
cor(G, E)

G <- -5:5 + rnorm(11,0,3)
E <- -5:5
cov(G, E)

# If G and E are independent, then scaling each one independently essentially gives a correlation:
cov(scale(G), scale(E))
cor(G, E)

# However, in our case, the G and E are not independent, because they are 
# both estimated from phenotype data. And because we scale the phenotype
# data before we calculate the G means and E means, with more than 2
# gentotypes this scaling has weird effects on the covariance.

# So this suggests that correlation is a better measure. However,
# we know that correlation doesn't work with only 2 genotypes 
# the correlation between two unequal points will either be -1 or 1

```

```{r}

beta1 = 1 # the amount the phenotype changes across 1 value of the environment (i.e., the slope). This is essentially the amount/degree of phenotypic plasticity that is the same across genotypes.

n_genotypes = 16 # the number of genotypes collected from different locations

beta2 = -1 # the amount the phenotype changes from one genotype to the next. This is essitially the increase intercept from one genotype to the next.

# Check #1
(E_real <- 1:n_genotypes)
(G_real <- (0:(n_genotypes-1))*beta2)
(cov_GE = cov(E_real, G_real))  # true cov for raw data
(cor_GE = cor(E_real, G_real))

# old approximation
(cov_GE_approx = beta1 * beta2) 
  # will be correlated with the magnitude of cov(G,E)

# SANITY CHECK
# IF WE DO A RECIPROCAL TRANSPLANT WITH 10 Locations and 
# 15 samples per location, we should get:
# 10 genotypes x 10 locations = 100 treatments x 15 samples = 1500 measurements

# The old code had a bug, in that it was only generating the correct data
# for the 2 population case, and not for cases with more than 2 populations

# Generate data
n = 15 # sample size
n_environments = n_genotypes # the number of common garden environments that the genotypes are grown in. Basically, genotype[i] orginates from environment[i]. This matching between genotypes and environment is important for the the cov(G,E) calculation. Here, we only consider the case of the complete reciprocal transplant experiment.

## Create levels of genotypes and environments ####
G = rep(1:n_genotypes, each=n*n_genotypes) # '0' n times, '1' n times
E = rep(1:n_environments,times=n*n_genotypes) # '0'x50, '1'x50, '0'x50, '1'x50
set.seed(97)
e = rnorm(n*n_genotypes, 0, sd=0.01) # Random noise, with standard deviation of 1
#e = 0 # EVALUATION

## Create interaction effect for each level of both factors ####
# In this case we assume the GxE interactions are a 
# normally distributed random variable with a mean of 0
# As the sd increases, so does the GxE among treatments
int <- 0#rnorm(n_genotypes * n_environments, 0, sd=10)
#int <- 0 # EVALUATION
 
 # this sd determines the amount of GxE
int_df <- data.frame(expand.grid(G=1:n_genotypes, E=1:n_environments), 
                     int)

### Create the model dataframe ####
model_df <- data.frame(G, E, e)

model_df <- merge(model_df, int_df)
model_df <- model_df[order(model_df$G, model_df$E),]
dim(model_df)
head(model_df, 30)

# Generate phenotype data using the regression equation ####
phenotype = beta1*model_df$E + beta2*model_df$G  + model_df$e + model_df$int
model_df$phenotype = phenotype
head(model_df)

(E_means <- tapply(phenotype, model_df$E, mean))
(G_means <- tapply(phenotype, model_df$G, mean))
cov(E_means, G_means)
cor(E_means, G_means)
  # this should match the "true cov for raw data" I put above

# but the issue is we standardize the phenotype. So what happens when we do that?
phenotype_stn = (phenotype-mean(phenotype))/sd(phenotype)
(E_means_stn <- tapply(phenotype_stn, model_df$E, mean))
(G_means_stn <- tapply(phenotype_stn, model_df$G, mean))
plot(E_means_stn, G_means_stn)
cov(E_means_stn, G_means_stn)
cor(E_means_stn, G_means_stn)
  
plot(phenotype~model_df$E, col=model_df$G+1)

```

