beta2 = -1/n_genotypes # the amount the phenotype changes from one genotype to the next. This is essitially the increase intercept from one genotype to the next.
# Generate data
n = 15 # sample size
n_environments = n_genotypes # the number of common garden environments that the genotypes are grown in. Basically, genotype[i] orginates from environment[i]. This matching between genotypes and environment is important for the the cov(G,E) calculation. Here, we only consider the case of the complete reciprocal transplant experiment.
## Create levels of genotypes and environments ####
G = rep(1:n_genotypes, each=n*n_genotypes) # '0' n times, '1' n times
E = rep(1:n_environments,times=n*n_genotypes) # '0'x50, '1'x50, '0'x50, '1'x50
set.seed(97)
e = rnorm(n*n_genotypes, 0, sd=0.01) # Random noise, with standard deviation of 1
e = 0 # EVALUATION
## Create interaction effect for each level of both factors ####
# In this case we assume the GxE interactions are a
# normally distributed random variable with a mean of 0
# As the sd increases, so does the GxE among treatments
int <- rnorm(n_genotypes * n_environments, 0, sd=1)
int <- 0 # EVALUATION
# this sd determines the amount of GxE
int_df <- data.frame(expand.grid(G=1:n_genotypes, E=1:n_environments),
int)
### Create the model dataframe ####
model_df <- data.frame(G, E, e)
model_df <- merge(model_df, int_df)
model_df <- model_df[order(model_df$G, model_df$E),]
dim(model_df)
head(model_df, 30)
# Generate phenotype data using the regression equation ####
phenotype = beta1*model_df$E + beta2*model_df$G  + model_df$e + model_df$int
model_df$phenotype = phenotype
head(model_df)
(E_means <- tapply(phenotype, model_df$E, mean))
(G_means <- tapply(phenotype, model_df$G, mean))
cov(E_means, G_means)
# but the issue is we standardize the phenotype. So what happens when we do that?
phenotype_stn = (phenotype-mean(phenotype))/sd(phenotype)
(E_means_stn <- tapply(phenotype_stn, model_df$E, mean))
(G_means_stn <- tapply(phenotype_stn, model_df$G, mean))
cov(E_means_stn, G_means_stn)
beta2 = -1*n_genotypes # the amount the phenotype changes from one genotype to the next. This is essitially the increase intercept from one genotype to the next.
# Check #1
(E_real <- 1:n_genotypes)
(G_real <- (0:(n_genotypes-1))*beta2)
(cov_GE = cov(E_real, G_real))  # true cov for raw data
# old approximation
(cov_GE_approx = beta1 * beta2)
# Generate data
n = 15 # sample size
n_environments = n_genotypes # the number of common garden environments that the genotypes are grown in. Basically, genotype[i] orginates from environment[i]. This matching between genotypes and environment is important for the the cov(G,E) calculation. Here, we only consider the case of the complete reciprocal transplant experiment.
## Create levels of genotypes and environments ####
G = rep(1:n_genotypes, each=n*n_genotypes) # '0' n times, '1' n times
E = rep(1:n_environments,times=n*n_genotypes) # '0'x50, '1'x50, '0'x50, '1'x50
set.seed(97)
e = rnorm(n*n_genotypes, 0, sd=0.01) # Random noise, with standard deviation of 1
e = 0 # EVALUATION
## Create interaction effect for each level of both factors ####
# In this case we assume the GxE interactions are a
# normally distributed random variable with a mean of 0
# As the sd increases, so does the GxE among treatments
int <- rnorm(n_genotypes * n_environments, 0, sd=1)
int <- 0 # EVALUATION
# this sd determines the amount of GxE
int_df <- data.frame(expand.grid(G=1:n_genotypes, E=1:n_environments),
int)
### Create the model dataframe ####
model_df <- data.frame(G, E, e)
model_df <- merge(model_df, int_df)
model_df <- model_df[order(model_df$G, model_df$E),]
dim(model_df)
head(model_df, 30)
# Generate phenotype data using the regression equation ####
phenotype = beta1*model_df$E + beta2*model_df$G  + model_df$e + model_df$int
model_df$phenotype = phenotype
head(model_df)
(E_means <- tapply(phenotype, model_df$E, mean))
(G_means <- tapply(phenotype, model_df$G, mean))
cov(E_means, G_means)
# but the issue is we standardize the phenotype. So what happens when we do that?
phenotype_stn = (phenotype-mean(phenotype))/sd(phenotype)
(E_means_stn <- tapply(phenotype_stn, model_df$E, mean))
(G_means_stn <- tapply(phenotype_stn, model_df$G, mean))
cov(E_means_stn, G_means_stn)
plot(phenotype~model_df$E, col=model_df$G+1)
beta1 = 1*(n_genotypes-1) # the amount the phenotype changes across 1 value of the environment (i.e., the slope). This is essentially the amount/degree of phenotypic plasticity that is the same across genotypes.
n_genotypes = 10 # the number of genotypes collected from different locations
beta2 = -1 # the amount the phenotype changes from one genotype to the next. This is essitially the increase intercept from one genotype to the next.
# Check #1
(E_real <- 1:n_genotypes)
(G_real <- (0:(n_genotypes-1))*beta2)
(cov_GE = cov(E_real, G_real))  # true cov for raw data
# old approximation
(cov_GE_approx = beta1 * beta2)
# Generate data
n = 15 # sample size
n_environments = n_genotypes # the number of common garden environments that the genotypes are grown in. Basically, genotype[i] orginates from environment[i]. This matching between genotypes and environment is important for the the cov(G,E) calculation. Here, we only consider the case of the complete reciprocal transplant experiment.
## Create levels of genotypes and environments ####
G = rep(1:n_genotypes, each=n*n_genotypes) # '0' n times, '1' n times
E = rep(1:n_environments,times=n*n_genotypes) # '0'x50, '1'x50, '0'x50, '1'x50
set.seed(97)
e = rnorm(n*n_genotypes, 0, sd=0.01) # Random noise, with standard deviation of 1
e = 0 # EVALUATION
## Create interaction effect for each level of both factors ####
# In this case we assume the GxE interactions are a
# normally distributed random variable with a mean of 0
# As the sd increases, so does the GxE among treatments
int <- rnorm(n_genotypes * n_environments, 0, sd=1)
int <- 0 # EVALUATION
# this sd determines the amount of GxE
int_df <- data.frame(expand.grid(G=1:n_genotypes, E=1:n_environments),
int)
### Create the model dataframe ####
model_df <- data.frame(G, E, e)
model_df <- merge(model_df, int_df)
model_df <- model_df[order(model_df$G, model_df$E),]
dim(model_df)
head(model_df, 30)
# Generate phenotype data using the regression equation ####
phenotype = beta1*model_df$E + beta2*model_df$G  + model_df$e + model_df$int
model_df$phenotype = phenotype
head(model_df)
(E_means <- tapply(phenotype, model_df$E, mean))
(G_means <- tapply(phenotype, model_df$G, mean))
cov(E_means, G_means)
# but the issue is we standardize the phenotype. So what happens when we do that?
phenotype_stn = (phenotype-mean(phenotype))/sd(phenotype)
(E_means_stn <- tapply(phenotype_stn, model_df$E, mean))
(G_means_stn <- tapply(phenotype_stn, model_df$G, mean))
cov(E_means_stn, G_means_stn)
plot(phenotype~model_df$E, col=model_df$G+1)
beta1 = 1 # the amount the phenotype changes across 1 value of the environment (i.e., the slope). This is essentially the amount/degree of phenotypic plasticity that is the same across genotypes.
n_genotypes = 10 # the number of genotypes collected from different locations
beta2 = -1 # the amount the phenotype changes from one genotype to the next. This is essitially the increase intercept from one genotype to the next.
# Check #1
(E_real <- 1:n_genotypes)
(G_real <- (0:(n_genotypes-1))*beta2)
(cov_GE = cov(E_real, G_real))  # true cov for raw data
# old approximation
(cov_GE_approx = beta1 * beta2)
# Generate data
n = 15 # sample size
n_environments = n_genotypes # the number of common garden environments that the genotypes are grown in. Basically, genotype[i] orginates from environment[i]. This matching between genotypes and environment is important for the the cov(G,E) calculation. Here, we only consider the case of the complete reciprocal transplant experiment.
## Create levels of genotypes and environments ####
G = rep(1:n_genotypes, each=n*n_genotypes) # '0' n times, '1' n times
E = rep(1:n_environments,times=n*n_genotypes) # '0'x50, '1'x50, '0'x50, '1'x50
set.seed(97)
e = rnorm(n*n_genotypes, 0, sd=0.01) # Random noise, with standard deviation of 1
e = 0 # EVALUATION
## Create interaction effect for each level of both factors ####
# In this case we assume the GxE interactions are a
# normally distributed random variable with a mean of 0
# As the sd increases, so does the GxE among treatments
int <- rnorm(n_genotypes * n_environments, 0, sd=1)
int <- 0 # EVALUATION
# this sd determines the amount of GxE
int_df <- data.frame(expand.grid(G=1:n_genotypes, E=1:n_environments),
int)
### Create the model dataframe ####
model_df <- data.frame(G, E, e)
model_df <- merge(model_df, int_df)
model_df <- model_df[order(model_df$G, model_df$E),]
dim(model_df)
head(model_df, 30)
# Generate phenotype data using the regression equation ####
phenotype = beta1*model_df$E + beta2*model_df$G  + model_df$e + model_df$int
model_df$phenotype = phenotype
head(model_df)
(E_means <- tapply(phenotype, model_df$E, mean))
(G_means <- tapply(phenotype, model_df$G, mean))
cov(E_means, G_means)
# but the issue is we standardize the phenotype. So what happens when we do that?
phenotype_stn = (phenotype-mean(phenotype))/sd(phenotype)
(E_means_stn <- tapply(phenotype_stn, model_df$E, mean))
(G_means_stn <- tapply(phenotype_stn, model_df$G, mean))
cov(E_means_stn, G_means_stn)
beta1 = 1 # the amount the phenotype changes across 1 value of the environment (i.e., the slope). This is essentially the amount/degree of phenotypic plasticity that is the same across genotypes.
n_genotypes = 4 # the number of genotypes collected from different locations
beta2 = -1 # the amount the phenotype changes from one genotype to the next. This is essitially the increase intercept from one genotype to the next.
# Check #1
(E_real <- 1:n_genotypes)
(G_real <- (0:(n_genotypes-1))*beta2)
(cov_GE = cov(E_real, G_real))  # true cov for raw data
# old approximation
(cov_GE_approx = beta1 * beta2)
# Generate data
n = 15 # sample size
n_environments = n_genotypes # the number of common garden environments that the genotypes are grown in. Basically, genotype[i] orginates from environment[i]. This matching between genotypes and environment is important for the the cov(G,E) calculation. Here, we only consider the case of the complete reciprocal transplant experiment.
## Create levels of genotypes and environments ####
G = rep(1:n_genotypes, each=n*n_genotypes) # '0' n times, '1' n times
E = rep(1:n_environments,times=n*n_genotypes) # '0'x50, '1'x50, '0'x50, '1'x50
set.seed(97)
e = rnorm(n*n_genotypes, 0, sd=0.01) # Random noise, with standard deviation of 1
e = 0 # EVALUATION
## Create interaction effect for each level of both factors ####
# In this case we assume the GxE interactions are a
# normally distributed random variable with a mean of 0
# As the sd increases, so does the GxE among treatments
int <- rnorm(n_genotypes * n_environments, 0, sd=1)
int <- 0 # EVALUATION
# this sd determines the amount of GxE
int_df <- data.frame(expand.grid(G=1:n_genotypes, E=1:n_environments),
int)
### Create the model dataframe ####
model_df <- data.frame(G, E, e)
model_df <- merge(model_df, int_df)
model_df <- model_df[order(model_df$G, model_df$E),]
dim(model_df)
head(model_df, 30)
# Generate phenotype data using the regression equation ####
phenotype = beta1*model_df$E + beta2*model_df$G  + model_df$e + model_df$int
model_df$phenotype = phenotype
head(model_df)
(E_means <- tapply(phenotype, model_df$E, mean))
(G_means <- tapply(phenotype, model_df$G, mean))
cov(E_means, G_means)
# but the issue is we standardize the phenotype. So what happens when we do that?
phenotype_stn = (phenotype-mean(phenotype))/sd(phenotype)
(E_means_stn <- tapply(phenotype_stn, model_df$E, mean))
(G_means_stn <- tapply(phenotype_stn, model_df$G, mean))
cov(E_means_stn, G_means_stn)
plot(phenotype~model_df$E, col=model_df$G+1)
n_genotypes = 2 # the number of genotypes collected from different locations
beta2 = -1 # the amount the phenotype changes from one genotype to the next. This is essitially the increase intercept from one genotype to the next.
# Check #1
(E_real <- 1:n_genotypes)
(G_real <- (0:(n_genotypes-1))*beta2)
(cov_GE = cov(E_real, G_real))  # true cov for raw data
# old approximation
(cov_GE_approx = beta1 * beta2)
# Generate data
n = 15 # sample size
n_environments = n_genotypes # the number of common garden environments that the genotypes are grown in. Basically, genotype[i] orginates from environment[i]. This matching between genotypes and environment is important for the the cov(G,E) calculation. Here, we only consider the case of the complete reciprocal transplant experiment.
## Create levels of genotypes and environments ####
G = rep(1:n_genotypes, each=n*n_genotypes) # '0' n times, '1' n times
E = rep(1:n_environments,times=n*n_genotypes) # '0'x50, '1'x50, '0'x50, '1'x50
set.seed(97)
e = rnorm(n*n_genotypes, 0, sd=0.01) # Random noise, with standard deviation of 1
e = 0 # EVALUATION
## Create interaction effect for each level of both factors ####
# In this case we assume the GxE interactions are a
# normally distributed random variable with a mean of 0
# As the sd increases, so does the GxE among treatments
int <- rnorm(n_genotypes * n_environments, 0, sd=1)
int <- 0 # EVALUATION
# this sd determines the amount of GxE
int_df <- data.frame(expand.grid(G=1:n_genotypes, E=1:n_environments),
int)
### Create the model dataframe ####
model_df <- data.frame(G, E, e)
model_df <- merge(model_df, int_df)
model_df <- model_df[order(model_df$G, model_df$E),]
dim(model_df)
head(model_df, 30)
# Generate phenotype data using the regression equation ####
phenotype = beta1*model_df$E + beta2*model_df$G  + model_df$e + model_df$int
model_df$phenotype = phenotype
head(model_df)
(E_means <- tapply(phenotype, model_df$E, mean))
(G_means <- tapply(phenotype, model_df$G, mean))
cov(E_means, G_means)
# but the issue is we standardize the phenotype. So what happens when we do that?
phenotype_stn = (phenotype-mean(phenotype))/sd(phenotype)
(E_means_stn <- tapply(phenotype_stn, model_df$E, mean))
(G_means_stn <- tapply(phenotype_stn, model_df$G, mean))
cov(E_means_stn, G_means_stn)
plot(phenotype~model_df$E, col=model_df$G+1)
## what we want
## (x)*(y)/(n-1) = 1
x = -5:5
y = -5:5
cov(x,y)
(E_means_stn <- tapply(phenotype_stn, model_df$E, mean))
(G_means_stn <- tapply(phenotype_stn, model_df$G, mean))
n_genotypes = 16 # the number of genotypes collected from different locations
beta2 = -1 # the amount the phenotype changes from one genotype to the next. This is essitially the increase intercept from one genotype to the next.
# Check #1
(E_real <- 1:n_genotypes)
(G_real <- (0:(n_genotypes-1))*beta2)
(cov_GE = cov(E_real, G_real))  # true cov for raw data
# old approximation
(cov_GE_approx = beta1 * beta2)
# Generate data
n = 15 # sample size
n_environments = n_genotypes # the number of common garden environments that the genotypes are grown in. Basically, genotype[i] orginates from environment[i]. This matching between genotypes and environment is important for the the cov(G,E) calculation. Here, we only consider the case of the complete reciprocal transplant experiment.
## Create levels of genotypes and environments ####
G = rep(1:n_genotypes, each=n*n_genotypes) # '0' n times, '1' n times
E = rep(1:n_environments,times=n*n_genotypes) # '0'x50, '1'x50, '0'x50, '1'x50
set.seed(97)
e = rnorm(n*n_genotypes, 0, sd=0.01) # Random noise, with standard deviation of 1
e = 0 # EVALUATION
## Create interaction effect for each level of both factors ####
# In this case we assume the GxE interactions are a
# normally distributed random variable with a mean of 0
# As the sd increases, so does the GxE among treatments
int <- rnorm(n_genotypes * n_environments, 0, sd=1)
int <- 0 # EVALUATION
# this sd determines the amount of GxE
int_df <- data.frame(expand.grid(G=1:n_genotypes, E=1:n_environments),
int)
### Create the model dataframe ####
model_df <- data.frame(G, E, e)
model_df <- merge(model_df, int_df)
model_df <- model_df[order(model_df$G, model_df$E),]
dim(model_df)
head(model_df, 30)
# Generate phenotype data using the regression equation ####
phenotype = beta1*model_df$E + beta2*model_df$G  + model_df$e + model_df$int
model_df$phenotype = phenotype
head(model_df)
(E_means <- tapply(phenotype, model_df$E, mean))
(G_means <- tapply(phenotype, model_df$G, mean))
cov(E_means, G_means)
# but the issue is we standardize the phenotype. So what happens when we do that?
phenotype_stn = (phenotype-mean(phenotype))/sd(phenotype)
(E_means_stn <- tapply(phenotype_stn, model_df$E, mean))
(G_means_stn <- tapply(phenotype_stn, model_df$G, mean))
cov(E_means_stn, G_means_stn)
plot(phenotype~model_df$E, col=model_df$G+1)
plot(E_means_stn, G_means_stn)
cov(E_means_stn, G_means_stn*2)
cor(x,y)
n_genotypes = 4 # the number of genotypes collected from different locations
beta2 = -1 # the amount the phenotype changes from one genotype to the next. This is essitially the increase intercept from one genotype to the next.
# Check #1
(E_real <- 1:n_genotypes)
(G_real <- (0:(n_genotypes-1))*beta2)
(cov_GE = cov(E_real, G_real))  # true cov for raw data
# old approximation
(cov_GE_approx = beta1 * beta2)
# Generate data
n = 15 # sample size
n_environments = n_genotypes # the number of common garden environments that the genotypes are grown in. Basically, genotype[i] orginates from environment[i]. This matching between genotypes and environment is important for the the cov(G,E) calculation. Here, we only consider the case of the complete reciprocal transplant experiment.
## Create levels of genotypes and environments ####
G = rep(1:n_genotypes, each=n*n_genotypes) # '0' n times, '1' n times
E = rep(1:n_environments,times=n*n_genotypes) # '0'x50, '1'x50, '0'x50, '1'x50
set.seed(97)
e = rnorm(n*n_genotypes, 0, sd=0.01) # Random noise, with standard deviation of 1
e = 0 # EVALUATION
## Create interaction effect for each level of both factors ####
# In this case we assume the GxE interactions are a
# normally distributed random variable with a mean of 0
# As the sd increases, so does the GxE among treatments
int <- rnorm(n_genotypes * n_environments, 0, sd=1)
int <- 0 # EVALUATION
# this sd determines the amount of GxE
int_df <- data.frame(expand.grid(G=1:n_genotypes, E=1:n_environments),
int)
### Create the model dataframe ####
model_df <- data.frame(G, E, e)
model_df <- merge(model_df, int_df)
model_df <- model_df[order(model_df$G, model_df$E),]
dim(model_df)
head(model_df, 30)
# Generate phenotype data using the regression equation ####
phenotype = beta1*model_df$E + beta2*model_df$G  + model_df$e + model_df$int
model_df$phenotype = phenotype
head(model_df)
(E_means <- tapply(phenotype, model_df$E, mean))
(G_means <- tapply(phenotype, model_df$G, mean))
cov(E_means, G_means)
# but the issue is we standardize the phenotype. So what happens when we do that?
phenotype_stn = (phenotype-mean(phenotype))/sd(phenotype)
(E_means_stn <- tapply(phenotype_stn, model_df$E, mean))
(G_means_stn <- tapply(phenotype_stn, model_df$G, mean))
plot(E_means_stn, G_means_stn)
cov(E_means_stn, G_means_stn)
cor(E_means, G_means)
cor(E_means_stn, G_means_stn)
(cor_GE = cor(E_real, G_real))
cov(scale(x), scale(y))
cor(x,y)
cov(x,y)
n_genotypes = 3 # the number of genotypes collected from different locations
beta2 = -1 # the amount the phenotype changes from one genotype to the next. This is essitially the increase intercept from one genotype to the next.
# Check #1
(E_real <- 1:n_genotypes)
(G_real <- (0:(n_genotypes-1))*beta2)
(cov_GE = cov(E_real, G_real))  # true cov for raw data
(cor_GE = cor(E_real, G_real))
# old approximation
(cov_GE_approx = beta1 * beta2)
# Generate data
n = 15 # sample size
n_environments = n_genotypes # the number of common garden environments that the genotypes are grown in. Basically, genotype[i] orginates from environment[i]. This matching between genotypes and environment is important for the the cov(G,E) calculation. Here, we only consider the case of the complete reciprocal transplant experiment.
## Create levels of genotypes and environments ####
G = rep(1:n_genotypes, each=n*n_genotypes) # '0' n times, '1' n times
E = rep(1:n_environments,times=n*n_genotypes) # '0'x50, '1'x50, '0'x50, '1'x50
set.seed(97)
e = rnorm(n*n_genotypes, 0, sd=0.01) # Random noise, with standard deviation of 1
e = 0 # EVALUATION
## Create interaction effect for each level of both factors ####
# In this case we assume the GxE interactions are a
# normally distributed random variable with a mean of 0
# As the sd increases, so does the GxE among treatments
int <- rnorm(n_genotypes * n_environments, 0, sd=1)
int <- 0 # EVALUATION
# this sd determines the amount of GxE
int_df <- data.frame(expand.grid(G=1:n_genotypes, E=1:n_environments),
int)
### Create the model dataframe ####
model_df <- data.frame(G, E, e)
model_df <- merge(model_df, int_df)
model_df <- model_df[order(model_df$G, model_df$E),]
dim(model_df)
head(model_df, 30)
# Generate phenotype data using the regression equation ####
phenotype = beta1*model_df$E + beta2*model_df$G  + model_df$e + model_df$int
model_df$phenotype = phenotype
head(model_df)
(E_means <- tapply(phenotype, model_df$E, mean))
(G_means <- tapply(phenotype, model_df$G, mean))
cov(E_means, G_means)
cor(E_means, G_means)
# but the issue is we standardize the phenotype. So what happens when we do that?
phenotype_stn = (phenotype-mean(phenotype))/sd(phenotype)
(E_means_stn <- tapply(phenotype_stn, model_df$E, mean))
(G_means_stn <- tapply(phenotype_stn, model_df$G, mean))
plot(E_means_stn, G_means_stn)
cov(E_means_stn, G_means_stn)
cor(E_means_stn, G_means_stn)
scale(x)
n_genotypes = 2 # the number of genotypes collected from different locations
beta2 = -1 # the amount the phenotype changes from one genotype to the next. This is essitially the increase intercept from one genotype to the next.
# Check #1
(E_real <- 1:n_genotypes)
(G_real <- (0:(n_genotypes-1))*beta2)
(cov_GE = cov(E_real, G_real))  # true cov for raw data
(cor_GE = cor(E_real, G_real))
# old approximation
(cov_GE_approx = beta1 * beta2)
# Generate data
n = 15 # sample size
n_environments = n_genotypes # the number of common garden environments that the genotypes are grown in. Basically, genotype[i] orginates from environment[i]. This matching between genotypes and environment is important for the the cov(G,E) calculation. Here, we only consider the case of the complete reciprocal transplant experiment.
## Create levels of genotypes and environments ####
G = rep(1:n_genotypes, each=n*n_genotypes) # '0' n times, '1' n times
E = rep(1:n_environments,times=n*n_genotypes) # '0'x50, '1'x50, '0'x50, '1'x50
set.seed(97)
e = rnorm(n*n_genotypes, 0, sd=0.01) # Random noise, with standard deviation of 1
e = 0 # EVALUATION
## Create interaction effect for each level of both factors ####
# In this case we assume the GxE interactions are a
# normally distributed random variable with a mean of 0
# As the sd increases, so does the GxE among treatments
int <- rnorm(n_genotypes * n_environments, 0, sd=1)
int <- 0 # EVALUATION
# this sd determines the amount of GxE
int_df <- data.frame(expand.grid(G=1:n_genotypes, E=1:n_environments),
int)
### Create the model dataframe ####
model_df <- data.frame(G, E, e)
model_df <- merge(model_df, int_df)
model_df <- model_df[order(model_df$G, model_df$E),]
dim(model_df)
head(model_df, 30)
# Generate phenotype data using the regression equation ####
phenotype = beta1*model_df$E + beta2*model_df$G  + model_df$e + model_df$int
model_df$phenotype = phenotype
head(model_df)
n_genotypes = 2 # the number of genotypes collected from different locations
beta2 = -1 # the amount the phenotype changes from one genotype to the next. This is essitially the increase intercept from one genotype to the next.
# Check #1
(E_real <- 1:n_genotypes)
(G_real <- (0:(n_genotypes-1))*beta2)
(cov_GE = cov(E_real, G_real))  # true cov for raw data
(cor_GE = cor(E_real, G_real))
# old approximation
(cov_GE_approx = beta1 * beta2)
# Generate data
n = 15 # sample size
n_environments = n_genotypes # the number of common garden environments that the genotypes are grown in. Basically, genotype[i] orginates from environment[i]. This matching between genotypes and environment is important for the the cov(G,E) calculation. Here, we only consider the case of the complete reciprocal transplant experiment.
## Create levels of genotypes and environments ####
G = rep(1:n_genotypes, each=n*n_genotypes) # '0' n times, '1' n times
E = rep(1:n_environments,times=n*n_genotypes) # '0'x50, '1'x50, '0'x50, '1'x50
set.seed(97)
e = rnorm(n*n_genotypes, 0, sd=0.01) # Random noise, with standard deviation of 1
## Create interaction effect for each level of both factors ####
# In this case we assume the GxE interactions are a
# normally distributed random variable with a mean of 0
# As the sd increases, so does the GxE among treatments
int <- rnorm(n_genotypes * n_environments, 0, sd=1)
# this sd determines the amount of GxE
int_df <- data.frame(expand.grid(G=1:n_genotypes, E=1:n_environments),
int)
### Create the model dataframe ####
model_df <- data.frame(G, E, e)
model_df <- merge(model_df, int_df)
model_df <- model_df[order(model_df$G, model_df$E),]
dim(model_df)
head(model_df, 30)
# Generate phenotype data using the regression equation ####
phenotype = beta1*model_df$E + beta2*model_df$G  + model_df$e + model_df$int
model_df$phenotype = phenotype
head(model_df)
(E_means <- tapply(phenotype, model_df$E, mean))
(G_means <- tapply(phenotype, model_df$G, mean))
cov(E_means, G_means)
cor(E_means, G_means)
cov(G, E)
G <- -5:5
E <- -5:5
cov(G, E)
# If G and E are independent, then scaling each one independently essentially gives a correlation:
cov(scale(G), scale(E))
cor(G, E)
G <- -5:5 + rnorm(11,0,1)
E <- -5:5
cov(G, E)
G <- -5:5 + rnorm(11,0,3)
E <- -5:5
cov(G, E)
# If G and E are independent, then scaling each one independently essentially gives a correlation:
cov(scale(G), scale(E))
cor(G, E)
# old approximation
(cov_GE_approx = beta1 * beta2)
