---
title: "co-counter gradient variation"
author: "Katie Lotterhos"
date: "5/30/2019"
output: html_document
---
```{r}
# Co-gradient
G <- c(-1, 1) # When collecting real data, G will be vector of y-values
E <- c(1, -1) # E is vector of x-values
(covGE <- cov(G, E))
GxE = c(0, 0, 0, 0) #N1E1, N1E2, N2E1, N2E2

# countergradient
#G <- c(1, -1)
#E <- c(-1, 1)
#cov(G,E)
```

```{r}
### This function creates reciprocal transplant data ###
### returns the data, true cov(G,E), obs cov(G,E) ###

simulateGV <- function(G_diff_N1_N2, E_diff_N1_N2, n, GxE=c(0,0,0,0)){
  ## G_diff_N1_N2 genetic difference in phenotype from population N1 to N2
  ## E_diff_N1_N2 environment difference in phenotype from population N1 to N2
  ## n is the sample size per population-environment combo

  (G <- c(-G_diff_N1_N2/2, G_diff_N1_N2/2))
  (E <- c(-E_diff_N1_N2/2, E_diff_N1_N2/2))
  (covGE_true <- cov(G, E))
  #(corGE_true <- cor(G, E))

  P1_E1 <- G[1] + E[1] + GxE[1] + rnorm(n,0, 1)
  P1_E2 <- G[1] + E[2] + GxE[2] + rnorm(n,0, 1)
  P2_E1 <- G[2] + E[1] + GxE[3] + rnorm(n,0, 1)
  P2_E2 <- G[2] + E[2] + GxE[4] + rnorm(n,0, 1)

  phen <- c(P1_E1, P1_E2, P2_E1, P2_E2)
  gen <- rep(c("G1","G2"), each=n*2)
  env <- rep(c("E1", "E2", "E1", "E2"), each=n)

  data_GE <- data.frame(phen, gen, env)

  (covGE_data <- cov(c(mean(phen[gen=="G1"]),mean(phen[gen=="G2"])), 
    c(mean(phen[env=="E1"]), mean(phen[env=="E2"]))
    ))
  #(corGE_data <- cor(c(mean(phen[gen=="G1"]),mean(phen[gen=="G2"])), 
  #  c(mean(phen[env=="E1"]), mean(phen[env=="E2"]))
  #  ))
    

  return(list(data_GE=data_GE, 
              covGE_true=covGE_true, covGE_data=covGE_data)) 
              #corGE_true = corGE_true, corGE_data=corGE_data))
}
```

```{r}
bootstrapGV <- function(data_GE){

  ## ADD CODE TO STANDARDIZE PHENOTYPE DATA

  G_means <- NULL
  E_means <- NULL
  for (j in 1:nlevels(data_GE$gen)){
    cond_G <- data_GE$gen==levels(data_GE$gen)[j]
    G_means[j] <- mean(sample(data_GE$phen[cond_G], size=sum(cond_G), replace=TRUE))
    
    cond_E <- data_GE$env==levels(data_GE$env)[j]
    E_means[j] <- mean(sample(data_GE$phen[cond_E], size=sum(cond_E), replace=TRUE))
  }
  covGE_boot <- cov(G_means, E_means)
  #corGE_boot <- cor(G_means, E_means)
  return(list(covGE_boot))#, corGE_boot))
}
```

```{r}
## Loop through different effect sizes
## Loop through different sample sizes
## 100 replicates of each loop
## Power would be the proportion of replicates whose 95% CI are not including 0

replicate = c(1:100)
samplesize = seq(from = 1, to = 20, by = 1)
diff_effect = seq(from = 1, to = 30, by = 1)
simout <- data.frame()

for(j in 1:length(replicate)){ 
  replicate = replicate[j]
  for(k in 1:length(samplesize)){
  val = samplesize[k] 
  for(l in 1:length(diff_effect)){
    cat(j,k,l, "\n")  
    effect_val = diff_effect[l]
  simout_temp <- simulateGV(effect_val, effect_val, val) #Run function to generate data
  sampling_dist_cov <- replicate(1000, bootstrapGV(simout_temp$data_GE)[1], simplify=TRUE) #Bootstrap
  CI = quantile(unlist(sampling_dist_cov), probs=c(0.025, 0.975), type=1) #Get confidence intervals

#rownames(sampling_dist_cov) <- c("covGE_boot", "corGE_boot")
#sampling_dist_cov <- data.frame(as.matrix(unlist(t(sampling_dist_cov))))

## Data output  
  simoutk = data.frame("replicate" = replicate,
                       "samplesize" = val,
                       "GE_Diff" = effect_val,
                       "covGE_true" = simout_temp$covGE_true,
                       "covGE_data" = simout_temp$covGE_data, 
                       "lwrCI" = CI[1],
                       "uprCI" = CI[2])
simout = rbind(simout,simoutk)
}
}
}

```



```{r}
# cor
quantile(unlist(sampling_dist_cov[2,]), probs=c(0.025, 0.975), type=1)
# this is always 1 or -1 because we only have 2 data points

### Things to think about
# Do we standardize phenotype data before we put it in here? Yes, mean = 0, stdev = 1
# If no to the last question, do we standardize the covariance as a correlation?

boxplot(phen~gen)

var(phen)

# jacknife loop through all datapoints
# remove one datapoint 
# calculate the estimate
# can prodcue 95% CI on the parameter (in this case is cov)
```