---
title: "co-counter gradient variation"
author: "Katie Lotterhos"
date: "5/30/2019"
output: html_document
---
```{r}
# Co-gradient
G <- c(-1, 1) # When collecting real data, G will be vector of y-values
E <- c(1, -1) # E is vector of x-values
(covGE <- cov(G, E))
GxE = c(0, 0, 0, 0) #N1E1, N1E2, N2E1, N2E2

# countergradient
#G <- c(1, -1)
#E <- c(-1, 1)
#cov(G,E)
```

```{r}
### This function creates reciprocal transplant data ###
### returns the data, true cov(G,E), obs cov(G,E) ###

simulateGV <- function(G_diff_N1_N2, E_diff_N1_N2, n, GxE=c(0,0,0,0)){
  ## G_diff_N1_N2 genetic difference in phenotype from population N1 to N2
  ## E_diff_N1_N2 environment difference in phenotype from population N1 to N2
  ## n is the sample size per population-environment combo

  (G <- c(-G_diff_N1_N2/2, G_diff_N1_N2/2))
  (E <- c(-E_diff_N1_N2/2, E_diff_N1_N2/2))
  (covGE_true <- cov(G, E))
  #(corGE_true <- cor(G, E))

  P1_E1 <- G[1] + E[1] + GxE[1] + rnorm(n,0, 1)
  P1_E2 <- G[1] + E[2] + GxE[2] + rnorm(n,0, 1)
  P2_E1 <- G[2] + E[1] + GxE[3] + rnorm(n,0, 1)
  P2_E2 <- G[2] + E[2] + GxE[4] + rnorm(n,0, 1)

  phen <- c(P1_E1, P1_E2, P2_E1, P2_E2)
  gen <- rep(c("G1","G2"), each=n*2)
  env <- rep(c("E1", "E2", "E1", "E2"), each=n)

  data_GE <- data.frame(phen, gen, env)

  (covGE_data <- cov(c(mean(phen[gen=="G1"]),mean(phen[gen=="G2"])), 
    c(mean(phen[env=="E1"]), mean(phen[env=="E2"]))
    ))
  #(corGE_data <- cor(c(mean(phen[gen=="G1"]),mean(phen[gen=="G2"])), 
  #  c(mean(phen[env=="E1"]), mean(phen[env=="E2"]))
  #  ))
    

  return(list(data_GE=data_GE, 
              covGE_true=covGE_true, covGE_data=covGE_data)) 
              #corGE_true = corGE_true, corGE_data=corGE_data))
}
```

```{r}
bootstrapGV <- function(data_GE){

  ## ADD CODE TO STANDARDIZE PHENOTYPE DATA

  G_means <- NULL
  E_means <- NULL
  for (j in 1:nlevels(data_GE$gen)){
    cond_G <- data_GE$gen==levels(data_GE$gen)[j]
    G_means[j] <- mean(sample(data_GE$phen[cond_G], size=sum(cond_G), replace=TRUE))
    
    cond_E <- data_GE$env==levels(data_GE$env)[j]
    E_means[j] <- mean(sample(data_GE$phen[cond_E], size=sum(cond_E), replace=TRUE))
  }
  covGE_boot <- cov(G_means, E_means)
  #corGE_boot <- cor(G_means, E_means)
  return(list(covGE_boot))#, corGE_boot))
}
```

```{r}
## Loop through different effect sizes
## Loop through different sample sizes
## 100 replicates of each loop
setwd("~/Documents/GitHub/CnGV/src/")

cores=detectCores()
cl <- makeCluster(cores[1]-1) #not to overload your computer
registerDoParallel(cl)

#rep = c(1:2)
nsims = 100
samplesize = seq(from = 1, to = 30, by = 1)
diff_effect = seq(from = 1, to = 10, by = 0.25)
simout <- data.frame(data.frame(#"replicate" = 0,
                       "samplesize" = 0,
                       "GE_Diff" = 0,
                       "covGE_true" = 0,
                       "covGE_data" = 0, 
                       "lwrCI" = 0,
                       "uprCI" = 0))
row = 0 # for indexing

foreach(s = 1:nsims, .combine = rbind) %dopar% { 

  for(k in 1:length(samplesize)) {
     for(l in 1:length(diff_effect)) {
       
       row=row+1 #index for the for mini-data file
       
       # Setting parameters for this run
       val = samplesize[k] 
       effect_val = diff_effect[l]
       #cat(j,k,l, "\n")  
       
       simout_temp <- simulateGV(effect_val, effect_val, val) #Run function to generate data
       sampling_dist_cov <- replicate(1000, bootstrapGV(simout_temp$data_GE)[1], simplify=TRUE) #Bootstrap
       CI = quantile(unlist(sampling_dist_cov), probs=c(0.025, 0.975), type=1) #Get confidence intervals

## Data output  
  simout[row,] = data.frame(#"replicate" = rep,
                       "samplesize" = val,
                       "GE_Diff" = effect_val,
                       "covGE_true" = simout_temp$covGE_true,
                       "covGE_data" = simout_temp$covGE_data, 
                       "lwrCI" = CI[1],
                       "uprCI" = CI[2])
        #}
     }
}
 write.csv(simout,paste("SimResults_06042019",s,".csv",sep="_"),row.names=FALSE)
}


```
*Power Heatmap*

Power is the proportion of replicates whose 95% CI are not including 0

```{r}
## Load data from simulations
simdat = read.csv("~/Desktop/Work/RCN-ECS/CNGV_Meta_analysis/Simulations/Simulation_06032019.csv")
str(simdat)
simdat = simdat[,-1]

## Synthesize sims to get proportion of replicates that have CIs that cross zero
simdat$overunder = 0
for(i in 1:nrow(simdat)){
 if (simdat$lwrCI[i] <= 0){simdat$overunder[i] = 1}
  else if (simdat$uprCI[i] <= 0){simdat$overunder[i] = 1}
  else  simdat$overunder[i] = 0
}

simdat2 = simdat %>% #To calculate the proportion individuals that have CIs that cross zero
  group_by(samplesize,GE_Diff) %>%
  summarise(ct = length(overunder),
            cat = sum(overunder),
            prop = (cat/ct))

simplot = ggplot(data = simdat2, aes(x = GE_Diff, y = prop), group = factor(samplesize), colour = factor(samplesize)) +
  geom_line(aes(x = GE_Diff, y = prop, group = factor(samplesize),colour = factor(samplesize)))+
  theme_bw()+ xlim(1,20)+
  ylab("Proportion sims crossing zero") + xlab("Difference in G and E")+
  theme_bw(base_size = 30, base_family = "Helvetica")+ 
  theme(strip.background =element_rect(fill="white"))+
  theme(strip.text = element_text(colour = 'black')) +
  theme(plot.background = element_blank(),panel.grid.major = element_blank(),panel.grid.minor = element_blank())+
  theme(axis.ticks = element_line(colour = "black"))+
  theme(axis.text= element_text(colour = "black"))+
  labs(colour = "Sample Size")+
  theme(legend.position="bottom")+
  theme(legend.title = element_text(size = 14),
          legend.text = element_text(size = 14))
  #theme(legend.position="none")
simplot

```

*Extra code*
May want to use in the future. We had correlation, but I (MA) removed it from current code since we are only using 2 estimates for G and E and therefore cannot estimate a correlation. 
```{r}
## Was a part of code used in for-loop above, but presently unused. 
rownames(sampling_dist_cov) <- c("covGE_boot", "corGE_boot")
sampling_dist_cov <- data.frame(as.matrix(unlist(t(sampling_dist_cov))))

# cor
quantile(unlist(sampling_dist_cov[2,]), probs=c(0.025, 0.975), type=1)
# this is always 1 or -1 because we only have 2 data points

### Things to think about
# Do we standardize phenotype data before we put it in here? Yes, mean = 0, stdev = 1
# If no to the last question, do we standardize the covariance as a correlation?

boxplot(phen~gen)

var(phen)

# jacknife loop through all datapoints
# remove one datapoint 
# calculate the estimate
# can prodcue 95% CI on the parameter (in this case is cov)
```