---
title: "Cov_Functions"
output: html_document
---

To provide a quantitative framework for the analysis of cogradient and countergradient variation in nature, Katie Lotterhos, Molly Albecker, and Geoff Trussell use the below functions to simulate data, conduct power analyses, and analyze data extracted from published empirical work. The following functions are sourced into the actual analyses in the "covGE.Rmd" file. 

```{r}
# Read in necessary packages for functions

packages_needed <- c("plyr","tidyverse","lme4","lmtest","gridExtra","ggplot2","MBESS","emmeans")

for (i in 1:length(packages_needed)){
  if(!(packages_needed[i] %in% installed.packages())){install.packages(packages_needed[i])}
}

for (i in 1:length(packages_needed)){
  library( packages_needed[i], character.only = TRUE)
}

```

```{r}

## For checking functions (temporary)

input_df = input # For simulation tests
a=b=c=d=e=f=g=h=i=j=k=l=m=n=o=p=z=1

#Continous environments
falc_dat = read.csv("~/Documents/GitHub/CnGV/data/Falconer_template.csv") # data for testing
lampei = read.csv("~/Desktop/4DataCollection_Template_studyID_743a.csv")

#Categorical environments
falc_dat_cat = read.csv("~/Documents/GitHub/CnGV/data/Falconer_template_categoricalenv.csv") 
gordon = read.csv("~/Downloads/4DataCollection_Template_studyID_654.csv")

#Means/SE with categorical or continuous (dataset altered to accomodate both)
faske = read.csv("~/Downloads/4DataCollection_Template_studyID_59g.csv") 

```

### Data Generation ###
For simulations, we will need to create data that mimics real data. To do so, we will generate new data using this function. 

```{r}

## Define starting parameters

Diff_GxE <- list(
  "type" = c("pure_GxE"), #("cogv","cngv","pure_GxE"),
  "intercept_G1" = 0,
  "slope_G1" = c(-2,-1,-0.25,0), #seq(from = -1, to = 1, by = 0.5),
  "intercept_G2" = c(0), #seq(from = -5, to = 5, by = 2),
  "slope_G2" = c(2,1,0.25,0), #seq(from = -1, to = 1, by = 0.1),
  "sd" = c(0), #seq(from = 0, to = 1, by = 0.5),
  "sample_size" = 5, #seq(from = 5, to = 10, by = 2),
  "env_num" = 2, #c(2,5,10), 
  "env" = NA,
  "G1_env" = NA, 
  "G2_env" = NA,
  "true_covGE" = NA, 
  "is.GxE" = NA, 
  "slope_diff" = NA) 

Diff_means <- list(
  "type" = c("cogv"), #c("cogv","cngv","pure_GxE"),
  "intercept_G1" = 0,
  "slope_G1" = c(2),#seq(from = -1, to = 1, by = 0.5),
  "intercept_G2" = c(2),#seq(from = -5, to = 5, by = 2),
  "slope_G2" = c(-2),#seq(from = -1, to = 1, by = 0.1),
  "sd" = c(1),#seq(from = 0, to = 1, by = 0.5),
  "sample_size" = c(5),#seq(from = 5, to = 10, by = 2),
  "env_num" = 2,#c(2,5,10), 
  "env" = NA,
  "G1_env" = NA, 
  "G2_env" = NA,
  "true_covGE" = NA, 
  "is.GxE" = NA, 
  "slope_diff" = NA) 

input_df = Diff_GxE # For simulation tests

```

```{r}
# To create data: 

data_generation <- function(input_df){
  
  dat_temp = data.frame()
  row=0 #for indexing
  
  # Starting Parameters
  type = input_df$type
  intercept_G1 = input_df$intercept_G1
  slope_G1 = input_df$slope_G1
  intercept_G2 = input_df$intercept_G2
  slope_G2 = input_df$slope_G2
  sd = input_df$sd
  sample_size = input_df$sample_size
  G1_env = input_df$G1_env
  G2_env = input_df$G2_env
  env_num = input_df$env_num
  env = input_df$env
  true_covGE = input_df$true_covGE
  is.GxE = input_df$is.GxE
  slope_diff = input_df$slope_diff
  
  
  for(a in 1:length(unique(env_num))){ 
    for(b in 1:length(unique(type))){
    
    env_num_temp = unique(env_num)[a]
    type_temp = type[b]
  
    # Set environmental parameters (x-axis)
    if(env_num_temp == 2){env = c(-2,2)
    }else if (env_num_temp == 5){env = c(-2,-1,0,1,2)
    }else{env = seq(from = -2.5, to = 2, by = 0.5)}
    
    # Match genotypes to phenotypes
    if(type_temp == "cngv"){((G1_env= 2) & (G2_env = -2)) 
      }else{ ((G1_env= -2) & (G2_env = 2))}
    
    for(d in 1:length(slope_G1)){
      for(e in 1:length(intercept_G2)){
        for(f in 1:length(slope_G2)){
          for(g in 1:length(sd)){
            for(h in 1:length(sample_size)){
                
                row=row+1 #index 
                  
                  # GxE logical
                  if(slope_G1[d] == slope_G2[f]){is.GxE = "No_GxE"} else {is.GxE = "Yes_GxE"}
                  
                  # Difference in slope and intercept
                  slope_diff = abs(slope_G2[f] - slope_G1[d])
                  intercept_diff = (intercept_G2[e]-intercept_G1)
                  
                  # Generate data 
                    phen1 = c(replicate(sample_size[h],(intercept_G1 + slope_G1[d] * env + (rnorm(env_num_temp, 0, sd[g])))))
                    temp1 = data.frame("index" = row,
                                       "type" = rep(type_temp, length(env_num_temp*sample_size[h])),
                                       "is.GxE" = rep(is.GxE, length(env_num_temp*sample_size[h])),
                                       "env_num" = rep(env_num_temp, length(env_num_temp*sample_size[h])),
                                       "slope" = rep(slope_G1[d], length(env_num_temp*sample_size[h])),
                                       "slope_diff" = rep(slope_diff, length(env_num_temp*sample_size[h])),
                                       "intercept" = rep(intercept_G1, length(env_num_temp*sample_size[h])),
                                       "intercept_diff" = rep(intercept_diff, length(env_num_temp*sample_size[h])),
                                       "sample_size" = rep(sample_size[h], length(env_num_temp*sample_size[h])),
                                       "stdev" = rep(sd[g], length(env_num_temp*sample_size[h])),
                                       "native_env" = rep(G1_env,length(env_num_temp*sample_size[h])),
                                       "gen" = rep("G1", length(env_num_temp*sample_size[h])),
                                       "env" = rep(env, length(env_num_temp*sample_size[h])),
                                       "phen" = phen1)
                    
                    phen2 = c(replicate(sample_size[h], (intercept_G2[e] + slope_G2[f] * env + (rnorm(env_num_temp, 0, sd[g])))))
                    temp2 = data.frame("index" = row,
                                       "type" = rep(type_temp, length(env_num_temp*sample_size[h])),
                                       "is.GxE" = rep(is.GxE, length(env_num_temp*sample_size[h])),
                                       "env_num" = rep(env_num_temp, length(env_num_temp*sample_size[h])),
                                       "slope" = rep(slope_G2[f], length(env_num_temp*sample_size[h])),
                                       "slope_diff" = rep(slope_diff, length(env_num_temp*sample_size[h])),
                                       "intercept" = rep(intercept_G2[e], length(env_num_temp*sample_size[h])),
                                       "intercept_diff" = rep(intercept_diff, length(env_num_temp*sample_size[h])),
                                       "sample_size" = rep(sample_size[h], length(env_num_temp*sample_size[h])),
                                       "stdev" = rep(sd[g], length(env_num_temp*sample_size[h])),
                                       "native_env" = rep(G2_env,length(env_num_temp*sample_size[h])),
                                       "gen" = rep("G2", length(env_num_temp*sample_size[h])),
                                       "env" = rep(env, length(env_num_temp*sample_size[h])),
                                       "phen" = phen2)
                    dat_temp. = rbind(temp1, temp2)
                    dat_temp = rbind(dat_temp, dat_temp.)
            }
          }
        }
      }
    }
    }
    }
  return(dat_temp)
}

# Generate data for the GxE comparisons
new_data <- data_generation(Diff_GxE)

# Sanity check
for(i in 1:length(unique(new_data$index))){
  ind = unique(new_data$index)[i]
  plotdat = filter(new_data, index == ind)
  plot_temp = ggplot(plotdat, aes(x = env, y = phen, group = gen, fill = gen, colour = gen)) + 
    stat_smooth()  + theme_classic()
  print(plot_temp) 
}

```
To test whether means and SE can be reliably back calculated:
```{r}
mean_data1 <- data_generation(Diff_means)
mean_data1 = as.data.frame(mean_data)
bigdat = mean_data1
bigsumdat = data.frame()

#for(i in 1:length(unique(bigdat$rep))){
  for(j in 1:length(unique(bigdat$gen))){
    for (k in 1:length(unique(bigdat$env))){
  #reptemp = unique(bigdat$rep)[i]
  gentemp = unique(bigdat$gen)[j]
  envtemp = unique(bigdat$env)[k]
  #dat.. = filter(bigdat, rep == reptemp)
  dat. = filter(bigdat, gen==gentemp)
  dat = filter(dat., env == envtemp)
  average = mean(dat$phen)
  stddev = sd(dat$phen)
  bigsumdat. = data.frame("average" = average,
                          "std_dev" = stddev,
                          #"rep" = reptemp,
                          "gen" = gentemp,
                          "env" = envtemp,
                          "sample_size" = length(dat$phen))
  bigsumdat = rbind(bigsumdat, bigsumdat.)
    }
  }
bigsumdat$std_err = bigsumdat$std_dev/sqrt(bigsumdat$sample_size)

 # Go down to cont. function to obtain this new data.
olddat = lm(phen ~ env + gen, data = mean_data1)
newdata = lm(phen_data ~ exp_env_cat + gen_factor, data = newdat)

summary(olddat)
summary(newdata)
```

### Covariance Matrices ###

The purpose of the covariance matrix is to take raw data (either simulated or empirically-derived) and generate covariance estimates from those data. 

To generate covariance estimates, we use linear models to estimate lines and extract genotype and environmental means

May need to create different covariance matrices to deal with 3 kinds of data - simulated data, meta-analysis--raw-regression data, meta-analysis--raw-categorical data, meta-analysis--means data.


** Simulated Data Covariance Matrix **

```{r}

## Covariance Matrix Function for simulated data 

genphenenv_df= new_dat
genphenenv_df = new_dat

Cov_matrix_sim <- function(genphenenv_df){
  
  # Output Dataframes
  mod_dat = data.frame()
  Cov_matrix = data.frame()
  model_specs = data.frame()
  
  # Splits into different dataframes
  for(x in 1:length(unique(genphenenv_df$index))){
    id = unique(genphenenv_df$index)[x]
    ind_dat = genphenenv_df[genphenenv_df$index == id,]
    
    # Standardize data
    dat_avg = mean(ind_dat$phen) 
    dat_std = sd(ind_dat$phen)
    env_avg = mean(ind_dat$env) 
    env_std = sd(ind_dat$env)
    ind_dat$phen_corrected = ((ind_dat$phen-dat_avg)/dat_std)
    ind_dat$env_corrected = ((ind_dat$env-env_avg)/env_std)
    
    # Model Comparison # run more on unstandardized too
    test_temp_a = lm(phen_corrected ~ env_corrected + gen, data = ind_dat)
    test_temp_b = lm(phen_corrected ~ env_corrected * gen, data = ind_dat)
    result = anova(test_temp_a,test_temp_b)
    
    # Model Outputs
    if(result[[2,6]] > 0.05){
      
      test_temp = lm(phen_corrected ~ env_corrected + gen, data = ind_dat)
      
      # Extract model outputs
      lm_result = "No_GxE"
      GxE_pval = result[[2,6]]
      emm_E = emmeans(test_temp, ~ env_corrected)
      emm_G = emmeans(test_temp, ~ gen)
      emm_GxE = NA
      G1_slope_predicted = test_temp[[1]][2]
      G2_slope_predicted = (test_temp[[1]][[2]]+test_temp[[1]][[3]])
      E_R2 = summary(aov(test_temp))[[1]][1,2]/sum(summary(aov(test_temp))[[1]][,2])
      G_R2 = summary(aov(test_temp))[[1]][2,2]/sum(summary(aov(test_temp))[[1]][,2])
      GxE_R2 = NA
      w2_env <- (summary(aov(test_temp))[[1]][1,2]-summary(aov(test_temp))[[1]][1,1]*summary(aov(test_temp))[[1]][4,3])/
        (sum(summary(aov(test_temp))[[1]][,2])+summary(aov(test_temp))[[1]][4,3])
      w2_gen <- (summary(aov(test_temp))[[1]][2,2]-summary(aov(test_temp))[[1]][2,1]*summary(aov(test_temp))[[1]][4,3])/
        (sum(summary(aov(test_temp))[[1]][,2])+summary(aov(test_temp))[[1]][4,3])
      w2_GxE <- NA
      
      mod_dat. <- data.frame() 
      for(i in 1:length(test_temp[[1]])){
        id = names(test_temp[[1]][i]) 
        coef = test_temp[[1]][[i]]
        lwr_CI = confint(test_temp)[i,1]
        upr_CI = confint(test_temp)[i,2]
        pval = summary(test_temp)[[4]][i,4]
        mod_dat. = data.frame("index" = unique(ind_dat$index),
                              "id" = id,
                              "coef" = coef,
                              "lwr_CI" = lwr_CI,
                              "upr_CI" = upr_CI,
                              "pval" = pval)
        mod_dat. = rbind(mod_dat.,mod_dat..)  
      }
      mod_dat = rbind(mod_dat,mod_dat.)
      
      # Generate Matrices for Covariance and Permutations
      cov_temp <- data.frame(gen = rep(unique(ind_dat$gen),
                                       each = length(seq(from = min(ind_dat$env_corrected), 
                                                         to = (max(ind_dat$env_corrected)+0.1),by=0.1))),
                             env_corrected = seq(from = min(ind_dat$env_corrected), 
                                                 to = (max(ind_dat$env_corrected)+0.1),by=0.1))
      cov_temp$phen_predicted = predict(test_temp,cov_temp)
    }else{
      
      test_temp = lm(phen_corrected ~ env_corrected * gen, data = ind_dat)
      
      # Extract model outputs                
      lm_result = "Yes_GxE"
      GxE_pval = result[[2,6]]
      slope_predicted = simple_slopes(test_temp)
      G1_slope_predicted = slope_predicted[4,3]
      G2_slope_predicted = slope_predicted[5,3]
      emm_E = emmeans(test_temp, ~ env_corrected)
      emm_G = emmeans(test_temp, ~ gen)
      emm_GxE = emmeans(test_temp, ~ env_corrected*gen)
      E_R2 = summary(aov(test_temp))[[1]][1,2]/sum(summary(aov(test_temp))[[1]][,2])
      G_R2 = summary(aov(test_temp))[[1]][2,2]/sum(summary(aov(test_temp))[[1]][,2])
      GxE_R2 = summary(aov(test_temp))[[1]][3,2]/sum(summary(aov(test_temp))[[1]][,2])
      w2_env <- (summary(aov(test_temp))[[1]][1,2]-summary(aov(test_temp))[[1]][1,1]*summary(aov(test_temp))[[1]][4,3])/
        (sum(summary(aov(test_temp))[[1]][,2])+summary(aov(test_temp))[[1]][4,3])
      w2_gen <- (summary(aov(test_temp))[[1]][2,2]-summary(aov(test_temp))[[1]][2,1]*summary(aov(test_temp))[[1]][4,3])/
        (sum(summary(aov(test_temp))[[1]][,2])+summary(aov(test_temp))[[1]][4,3])
      w2_GxE <- (summary(aov(test_temp))[[1]][3,2]-summary(aov(test_temp))[[1]][3,1]*summary(aov(test_temp))[[1]][4,3])/
        (sum(summary(aov(test_temp))[[1]][,2])+summary(aov(test_temp))[[1]][4,3])
      
      mod_dat. <- data.frame() 
      for(i in 1:length(test_temp[[1]])){
        id = names(test_temp[[1]][i]) 
        coef = test_temp[[1]][[i]]
        lwr_CI = confint(test_temp)[i,1]
        upr_CI = confint(test_temp)[i,2]
        pval = summary(test_temp)[[4]][i,4]
        mod_dat.. = data.frame("index" = unique(ind_dat$index),
                               "id" = id,
                               "coef" = coef,
                               "lwr_CI" = lwr_CI,
                               "upr_CI" = upr_CI,
                               "pval" = pval)
        mod_dat. = rbind(mod_dat.,mod_dat..)
      }
      mod_dat = rbind(mod_dat,mod_dat.)
      
      # Generate Matrices for Covariance and Permutations
      cov_temp <- data.frame(gen = rep(unique(ind_dat$gen),
                                       each = length(seq(from = min(ind_dat$env_corrected), 
                                                         to = (max(ind_dat$env_corrected)+0.1),by=0.1))),
                             env_corrected = seq(from = min(ind_dat$env_corrected), 
                                                 to = (max(ind_dat$env_corrected)+0.1),by=0.1))
      cov_temp$phen_predicted = predict(test_temp,cov_temp)
    }                 
    
    # Re-assign environmental variables
    cov_temp$env_corrected <- round(cov_temp$env_corrected,digits = 1) 
    cov_temp$native_env <- ind_dat$native_env[match(cov_temp$gen,ind_dat$gen)]
    ind_dat$env_corrected <- round(ind_dat$env_corrected, digits = 1)
    cov_temp$env <- ind_dat$env[match(cov_temp$env_corrected, ind_dat$env_corrected)]
    ngen <- length(unique(ind_dat$gen))
    
    # G_means
    E_hat = mean(ind_dat$env)
    G_means = cov_temp[cov_temp$env_corrected == E_hat,]
    
    # E_means
    E_mean_temp = data.frame()
    
    for(m in 1:length(unique(cov_temp$native_env))){
      E = unique(cov_temp$native_env)[m]
      E_temp = cov_temp[which(cov_temp$env == E),]
      E_mean = mean(E_temp$phen_predicted)
      E_mean_temp1 = data.frame("E_mean" = E_mean,
                                "env" = unique(E_temp$env))
      E_mean_temp = rbind(E_mean_temp, E_mean_temp1)
    }
    
    Cov_matrix. = data.frame("Index" = rep(unique(ind_dat$index),ngen),
                             "gen" = unique(cov_temp$gen),
                             "native_env" = as.factor(E_mean_temp[,2]),
                             "G_means" = unique(G_means$phen_predicted),
                             "E_means" = E_mean_temp[,1])
    Cov_matrix <- rbind(Cov_matrix,Cov_matrix.)
    
    cov_est = cov(Cov_matrix$G_means,Cov_matrix$E_means)
    overall_mean = mean(Cov_matrix[1,4],Cov_matrix[1,5],Cov_matrix[2,4],Cov_matrix[2,5])
    
    model_specs. = data.frame("Index" = unique(ind_dat$index),
                              "G1_slope" = unique(ind_dat$slope[ind_dat$gen == "G1"]),
                              "G1_slope_predicted" = G1_slope_predicted,
                              "G2_slope" = unique(ind_dat$slope[ind_dat$gen == "G2"]),
                              "G2_slope_predicted" = G2_slope_predicted,
                              "slope_diff" = unique(ind_dat$slope_diff),
                              "error" = unique(ind_dat$stdev),
                              "lm_result" = lm_result,
                              "GxE_pval" = GxE_pval,
                              "Covariance_est" = cov_est,
                              "eta_G" = G_R2,
                              "eta_E" = E_R2,
                              "eta_GxE" = GxE_R2,
                              "Interaction_G11" = overall_mean-summary(emm_G)[[1,2]]-summary(emm_E)[[2]]-Cov_matrix[1,4],
                              "Interaction_G12" = overall_mean-summary(emm_G)[[1,2]]-summary(emm_E)[[2]]-Cov_matrix[1,5],
                              "Interaction_G21" = overall_mean-summary(emm_G)[[1,3]]-summary(emm_E)[[2]]-Cov_matrix[2,4],
                              "Interaction_G22"= overall_mean-summary(emm_G)[[1,3]]-summary(emm_E)[[2]]-Cov_matrix[2,5],
                              "w2_env" = w2_env,
                              "w2_gen" = w2_gen,
                              "w2_GxE" = w2_GxE)
    model_specs <- rbind(model_specs,model_specs.)
    
  }
  return(list(mod_dat,Cov_matrix,model_specs))
}


testy = Cov_matrix_sim(new_dat)
```

```{r}
## To see how magnitude of GxE affects R^2
test_dat = data.frame()
for(i in 1:length(unique(new_data$index))){
  ind = unique(new_data$index)[i]
  filter_dat = new_data[new_data$index == ind,]
test_dat_temp <- Cov_matrix_sim(filter_dat)
test_dat <- rbind(test_dat,test_dat_temp[[3]])
}

test_dat$slopeset = paste(test_dat$G1_slope,test_dat$G2_slope,sep="_")
print(ggplot(test_dat, aes(x= reorder(slopeset,test_dat$G1_slope), y = GxE_R2)) + 
    geom_bar(stat = "identity",position="dodge")+theme_classic())+
    labs(x = "G1 - G2 Slope")
print(ggplot(test_dat, aes(x= slope_diff, y = GxE_R2)) + 
    geom_bar(stat = "identity",position="dodge")+theme_classic())+
    labs(x = "Slope Difference")

```

** Continuous Environments Covariance Matrix **

```{r}

## Covariance Matrix Function for meta-analysis data with continuous environments: 

Cov_matrix_continuous <- function(genphenenv_df){

  # Standardize data
  phen_mean = mean(genphenenv_df$phen_data) 
  phen_sd = sd(genphenenv_df$phen_data) 
  nat_env_mean = mean(genphenenv_df$nat_env_mean) 
  nat_env_sd = sd(genphenenv_df$nat_env_mean)
  env_avg = mean(genphenenv_df$exp_env_cont) 
  env_std = sd(genphenenv_df$exp_env_cont)
  genphenenv_df$phen_corrected = ((genphenenv_df$phen_data-phen_mean)/phen_sd)
  genphenenv_df$env_corrected = ((genphenenv_df$exp_env_cont-env_avg)/env_std) 
  genphenenv_df$native_env_corrected = ((genphenenv_df$nat_env_mean-env_avg)/env_std) 
  
  # Model Comparison
  test_temp_a = lm(phen_corrected ~ env_corrected + gen_factor, data = genphenenv_df)
  test_temp_b = lm(phen_corrected ~ env_corrected * gen_factor, data = genphenenv_df)
  result = anova(test_temp_a,test_temp_b)
  
  # Model Outputs
  if(result[[2,6]] > 0.05){
    
  test_temp = lm(phen_corrected ~ env_corrected + gen_factor, data = genphenenv_df)
  
  # Model diagnostics
  res = residuals(test_temp)
  shap_wilkes = shapiro.test(res)
  is.normal <- NULL
  if(shap_wilkes[[2]] > 0.05){is.normal = "Yes"}else{is.normal = "No"}
  if(length(unique(genphenenv_df$env_corrected))>2){ # Wont work if only 2 environments
    test_nonlinear = lm(phen_corrected ~ (exp_env_factor^2) + gen_factor, data = genphenenv_df) #Polynomial 
  lin_test = lrtest(test_temp,test_nonlinear) # If p > 0.05, then data likely non-linear
  is.linear <- NULL
  if(lin_test[[2,5]] > 0.05){is.linear = "No"}else{is.linear = "Yes"}
  }else{is.linear <- "NA"}
  
  # Extract model outputs
  lm_result = "No_GxE"
  GxE_pval = result[[2,6]]
  E_R2 = summary(aov(test_temp))[[1]][1,2]/sum(summary(aov(test_temp))[[1]][,2])
  G_R2 = summary(aov(test_temp))[[1]][2,2]/sum(summary(aov(test_temp))[[1]][,2])
  GxE_R2 = NA

  mod_dat = data.frame()
  for(i in 1:length(test_temp[[1]])){
    id = names(test_temp[[1]][i]) 
    coef = test_temp[[1]][[i]]
    lwr_CI = confint(test_temp)[i,1]
    upr_CI = confint(test_temp)[i,2]
    pval = summary(test_temp)[[4]][i,4]
    mod_dat. = data.frame("id" = id,
                          "coef" = coef,
                          "lwr_CI" = lwr_CI,
                          "upr_CI" = upr_CI,
                          "pval" = pval)
    mod_dat = rbind(mod_dat,mod_dat.)
  }
  
  # Generate Matrices for Covariance and Permutations
  cov_temp <- data.frame(gen_factor = rep(genphenenv_df$gen_factor,
                                          each = length(seq(from = min(genphenenv_df$env_corrected), 
                                                            to = max(genphenenv_df$env_corrected),  by = 0.1))),
                         env_corrected = seq(from = min(genphenenv_df$env_corrected), 
                                             to = max(genphenenv_df$env_corrected), by = 0.1))
  cov_temp$phen_predicted = predict(test_temp,cov_temp)
  }else{
    
  test_temp = lm(phen_corrected ~ env_corrected * gen_factor, data = genphenenv_df)
  
  # Model diagnostics
  res = residuals(test_temp)
  shap_wilkes = shapiro.test(res)
  is.normal <- NULL
  if(shap_wilkes[[2]] > 0.05){is.normal = "Yes"}else{is.normal = "No"}
  if(length(unique(genphenenv_df$env_corrected))>2){ # Wont work if only 2 environments
    test_nonlinear = lm(phen_corrected ~ (exp_env_factor^2) + gen_factor, data = genphenenv_df) #Polynomial 
  lin_test = lrtest(test_temp,test_nonlinear) # If p > 0.05, then data likely non-linear
  is.linear <- NULL
  if(lin_test[[2,5]] > 0.05){is.linear = "No"}else{is.linear = "Yes"}
  }else{is.linear <- "NA"}

  # Extract model outputs                
  lm_result = "Yes_GxE"
  GxE_pval = result[[2,6]]
  E_R2 = summary(aov(test_temp))[[1]][1,2]/sum(summary(aov(test_temp))[[1]][,2])
  G_R2 = summary(aov(test_temp))[[1]][2,2]/sum(summary(aov(test_temp))[[1]][,2])
  GxE_R2 = summary(aov(test_temp))[[1]][3,2]/sum(summary(aov(test_temp))[[1]][,2])
   
  mod_dat = data.frame()
  for(i in 1:length(test_temp[[1]])){
    id = names(test_temp[[1]][i]) 
    coef = test_temp[[1]][[i]]
    lwr_CI = confint(test_temp)[i,1]
    upr_CI = confint(test_temp)[i,2]
    pval = summary(test_temp)[[4]][i,4]
    mod_dat. = data.frame("id" = id,
                          "coef" = coef,
                          "lwr_CI" = lwr_CI,
                          "upr_CI" = upr_CI,
                          "pval" = pval)
    mod_dat = rbind(mod_dat,mod_dat.)
  }
 
  # Generate Matrices for Covariance and Permutations
  cov_temp <- data.frame(gen_factor = rep(genphenenv_df$gen_factor,
                                          each = length(seq(from = min(genphenenv_df$env_corrected), 
                                                            to = max(genphenenv_df$env_corrected),  by = 0.1))),
                         env_corrected = seq(from = min(genphenenv_df$env_corrected), 
                                             to = max(genphenenv_df$env_corrected), by = 0.1))
  cov_temp$phen_predicted = predict(test_temp,cov_temp)
  }                 

  # Re-assign environmental variables to model predicted data 
  cov_temp$native_env_corrected <- genphenenv_df$native_env_corrected[match(cov_temp$gen_factor,genphenenv_df$gen_factor)]
  cov_temp$env_corrected <- round(cov_temp$env_corrected, digits = 1)
  cov_temp$native_env_corrected <- round(genphenenv_df$native_env_corrected[match(cov_temp$gen_factor,genphenenv_df$gen_factor)],
                                         digits =1)
  
  # Covariance Emeans and Gmeans
  Cov_matrix = data.frame()
  
  # G_means
  E_hat = round(mean(cov_temp$env_corrected),digits = 1)
  G_means = filter(cov_temp, env_corrected == E_hat)
                  
  # E_means
  E_mean_temp = data.frame()
                    
  for(m in 1:length(unique(cov_temp$native_env_corrected))){
    E = unique(cov_temp$native_env_corrected)[m]
    E_temp = cov_temp[which(cov_temp$env_corrected == E),]
    E_mean = mean(unique(E_temp$phen_predicted))
    E_mean_temp1 = data.frame("E_mean" = E_mean,
                              "env_corrected" = unique(E_temp$env_corrected))
    E_mean_temp = rbind(E_mean_temp, E_mean_temp1)
    }
                    
    Cov_matrix = data.frame("gen_factor" = unique(cov_temp$gen_factor),
                            "native_env" = as.factor(E_mean_temp[,2]),
                            "G_means" = unique(G_means$phen_predicted),
                            "E_means" = E_mean_temp[,1])
    cov_est = cov(Cov_matrix$G_means,Cov_matrix$E_means)
    
    model_specs = data.frame("Covariance_est" = cov_est,
                             "is.normal" = is.normal,
                             "is.linear" = is.linear,
                             "lm_result" = lm_result,
                             "GxE_pval" = GxE_pval,
                             "E_R2" = E_R2,
                             "G_R2" = G_R2,
                             "GxE_R2" = GxE_R2)

    return(list(mod_dat,Cov_matrix,model_specs))
    
}

test_dat <- Cov_matrix_continuous(lampei)
test_dat[1] # Lampei = -0.19 : CNGV/Winner take all?
test_dat[2]
test_dat[3]

# to calculate effect sizes from t-values:
test_temp_a = aov(phen_corrected ~ env_corrected + gen_factor, data = genphenenv_df)
test_temp_b = aov(phen_corrected ~ env_corrected * gen_factor, data = genphenenv_df)
anova(test_temp_b)
summary(test_temp_b)

emm <- emmeans(test_temp_b,~env_corrected*)
eff_size(pairs(test_temp_b), sigma(fiber.lm), df.residual(fiber.lm), method = "identity")

omega.F(1, 868, 105.5, 876, a = 0.05)

## Sanity check

# Raw data
ggplot(lampei,aes(x = exp_env_cont, y = phen_data, group = gen_factor, fill = gen_factor, colour = gen_factor)) + 
  geom_smooth(method = "gam") + theme_classic()

# Raw Data after standardizing (have to run through function manually)
ggplot(genphenenv_df,aes(x = env_corrected, y = phen_corrected, group = gen_factor, fill = gen_factor, colour = gen_factor)) + 
  geom_smooth(method = "gam") + theme_classic()

# Model predicted data from function
ggplot(cov_temp,aes(x = env_corrected, y = phen_predicted, group = gen_factor, fill = gen_factor, colour = gen_factor)) + 
  geom_smooth(method = "gam") + theme_classic()

```
** Categorical Environments Covariance Matrix **
```{r}
## Covariance Matrix Function for meta-analysis data with categorical environments: 

Cov_matrix_categorical <- function(genphenenv_df){

  # Standardize data
  phen_mean = mean(genphenenv_df$phen_data) 
  phen_sd = sd(genphenenv_df$phen_data)
  genphenenv_df$phen_corrected = ((genphenenv_df$phen_data-phen_mean)/phen_sd)

  # Model Comparison
  test_temp_a = lm(phen_corrected ~ exp_env_factor + gen_factor, data = genphenenv_df)
  test_temp_b = lm(phen_corrected ~ exp_env_factor * gen_factor, data = genphenenv_df)
  result = anova(test_temp_a,test_temp_b)
  
  # Model Outputs
  if(result[[2,6]] > 0.05 ){
    
  test_temp = lm(phen_corrected ~ exp_env_factor + gen_factor, data = genphenenv_df)
  
  # Model diagnostics
  res = residuals(test_temp)
  shap_wilkes = shapiro.test(res)
  is.normal <- NULL
  if(shap_wilkes[[2]] > 0.05){is.normal = "Yes"}else{is.normal = "No"}
  if(length(unique(genphenenv_df$exp_env_factor))>2){ # Wont work if only 2 environments
    test_nonlinear = lm(phen_corrected ~ (exp_env_factor^2) + gen_factor, data = genphenenv_df) #Polynomial 
  lin_test = lrtest(test_temp,test_nonlinear) # If p > 0.05, then data likely non-linear
  is.linear <- NULL
  if(lin_test[[2,5]] > 0.05){is.linear = "No"}else{is.linear = "Yes"}
  }else{is.linear <- "NA"}
  
  # Extract model outputs
  lm_result = "No_GxE"
  GxE_pval = result[[2,6]]
  E_R2 = summary(aov(test_temp))[[1]][1,2]/sum(summary(aov(test_temp))[[1]][,2])
  G_R2 = summary(aov(test_temp))[[1]][2,2]/sum(summary(aov(test_temp))[[1]][,2])
  GxE_R2 = NA

  mod_dat = data.frame()
  for(i in 1:length(test_temp[[1]])){
    id = names(test_temp[[1]][i]) 
    coef = test_temp[[1]][[i]]
    lwr_CI = confint(test_temp)[i,1]
    upr_CI = confint(test_temp)[i,2]
    pval = summary(test_temp)[[4]][i,4]
    mod_dat. = data.frame("id" = id,
                          "coef" = coef,
                          "lwr_CI" = lwr_CI,
                          "upr_CI" = upr_CI,
                          "pval" = pval)
    mod_dat = rbind(mod_dat,mod_dat.)
  }
  
  # Generate Matrices for Covariance and Permutations
  cov_temp <- data.frame(gen_factor = genphenenv_df$gen_factor,
                         exp_env_factor = genphenenv_df$exp_env_factor)
  cov_temp$phen_predicted = predict(test_temp,cov_temp)
  }else{
    
  test_temp = lm(phen_corrected ~ exp_env_factor * gen_factor, data = genphenenv_df)
  
  # Model diagnostics
  res = residuals(test_temp)
  shap_wilkes = shapiro.test(res)
  is.normal <- NULL
  if(shap_wilkes[[2]] > 0.05){is.normal = "Yes"}else{is.normal = "No"}
  if(length(unique(genphenenv_df$exp_env_factor))>2){ # Wont work if only 2 environments
    test_nonlinear = lm(phen_corrected ~ (exp_env_factor^2) + gen_factor, data = genphenenv_df) #Polynomial 
  lin_test = lrtest(test_temp,test_nonlinear) # If p > 0.05, then data likely non-linear
  is.linear <- NULL
  if(lin_test[[2,5]] > 0.05){is.linear = "No"}else{is.linear = "Yes"}
  }else{is.linear <- "NA"}
  
  # Extract model outputs                
  lm_result = "Yes_GxE"
  GxE_pval = result[[2,6]]
  E_R2 = summary(aov(test_temp))[[1]][1,2]/sum(summary(aov(test_temp))[[1]][,2])
  G_R2 = summary(aov(test_temp))[[1]][2,2]/sum(summary(aov(test_temp))[[1]][,2])
  GxE_R2 = summary(aov(test_temp))[[1]][3,2]/sum(summary(aov(test_temp))[[1]][,2])
   
  mod_dat = data.frame()
  for(i in 1:length(test_temp[[1]])){
    id = names(test_temp[[1]][i]) 
    coef = test_temp[[1]][[i]]
    lwr_CI = confint(test_temp)[i,1]
    upr_CI = confint(test_temp)[i,2]
    pval = summary(test_temp)[[4]][i,4]
    mod_dat. = data.frame("id" = id,
                          "coef" = coef,
                          "lwr_CI" = lwr_CI,
                          "upr_CI" = upr_CI,
                          "pval" = pval)
    mod_dat = rbind(mod_dat,mod_dat.)
  } 
  
  # Generate Matrices for Covariance and Permutations
  cov_temp <- data.frame(gen_factor = genphenenv_df$gen_factor,
                         exp_env_factor = genphenenv_df$exp_env_factor)
  cov_temp$phen_predicted = predict(test_temp,cov_temp)
  }
  
  # Re-assign environmental variables
  cov_temp$nat_env_factor <- genphenenv_df$nat_env_factor[match(cov_temp$gen_factor,genphenenv_df$gen_factor)]
  
  # G_means
  G_mean_temp = data.frame()
  for(l in 1:length(unique(cov_temp$gen_factor))){
    G = unique(cov_temp$gen_factor)[l]
    G_temp = cov_temp[which(cov_temp$gen_factor == G),]
    G_mean = mean(unique(G_temp$phen_predicted))
    G_mean_temp1 = data.frame("G_mean" = G_mean,
                              "gen_factor" = G)
    G_mean_temp = rbind(G_mean_temp, G_mean_temp1)
}
                  
  # E_means
  E_mean_temp = data.frame()
                    
  for(m in 1:length(unique(cov_temp$nat_env_factor))){
    E = unique(cov_temp$nat_env_factor)[m]
    E_temp = cov_temp[which(cov_temp$nat_env_factor == E),]
    E_mean = mean(E_temp$phen_predicted)
    E_mean_temp1 = data.frame("E_mean" = E_mean,
                              "native_env" = E)
    E_mean_temp = rbind(E_mean_temp, E_mean_temp1)
    }
  
    ## Covariance Matrix  
    Cov_matrix = data.frame()                
    Cov_matrix = data.frame("gen" = G_mean_temp[,2],
                            "native_env" = as.factor(E_mean_temp[,2]),
                            "G_means" = G_mean_temp[,1],
                            "E_means" = E_mean_temp[,1])
    
    ## Estimate covariance
    cov_est = cov(Cov_matrix$G_means,Cov_matrix$E_means) 
    
    model_specs = data.frame("Covariance_est" = cov_est,
                             "is.normal" = is.normal,
                             "is.linear" = is.linear,
                             "lm_result" = lm_result,
                             "GxE_pval" = GxE_pval,
                             "E_R2" = E_R2,
                             "G_R2" = G_R2,
                             "GxE_R2" = GxE_R2)

    return(list(mod_dat,Cov_matrix,model_specs))
}

test_dat <- Cov_matrix_categorical(gordon)

## Sanity check

# Raw data
ggplot(gordon,aes(x = exp_env_factor, y = phen, group = gen_factor, fill = gen_factor, colour = gen_factor)) + 
  geom_smooth(method = "gam") + theme_classic()

# Raw Data after standardizing (have to run through function manually)
genphenenv_df = gordon
ggplot(genphenenv_df,aes(x = exp_env_factor, y = phen_corrected, group = gen_factor, fill = gen_factor, colour = gen_factor)) + 
  geom_smooth(method = "gam") + theme_classic()

# Model predicted data from function
ggplot(cov_temp,aes(x = exp_env_factor, y = phen_predicted, group = gen_factor, fill = gen_factor, colour = gen_factor)) + 
  geom_smooth(method = "gam") + theme_classic()

```
** Covariance Matrices from Means/SE with Categorical data **

Issue here: artificially inflating power to detect patterns that may not be real... how to deal?
```{r}
colnames(bigsumdat)[colnames(bigsumdat)=="average"] <- "phen_data"
colnames(bigsumdat)[colnames(bigsumdat)=="gen"] <- "gen_factor"
colnames(bigsumdat)[colnames(bigsumdat)=="env"] <- "exp_env_cat"
colnames(bigsumdat)[colnames(bigsumdat)=="sample_size"] <- "phen_n"
colnames(bigsumdat)[colnames(bigsumdat)=="std_err"] <- "phen_mean_SE"
genphenenv_df = bigsumdat

## Covariance Matrix Function for data with only means and SE reported/categorical envs: 
a=b=c=d=e=f=g=h=i=j=k=l=m=n=o=p=q=r=s=t=u=v=w=x=y=z=1

Cov_matrix_meanSE_categorical <- function(genphenenv_df){

  # Generate data based on normal distribution of data with MEAN/STDERROR
  newdat = data.frame()
  for(i in 1:nrow(genphenenv_df)){
    n = genphenenv_df$phen_n[i]
    u = genphenenv_df$phen_data[i]
    SE = genphenenv_df$phen_mean_SE[i]
    dat = rnorm(n,u,SE)
    newdat_temp = data.frame(gen_factor = rep(genphenenv_df$gen_factor[i],n),
                             #Native_env_cat = rep(genphenenv_df$Native_env_cat[i],n),
                             #nat_env_factor = rep(genphenenv_df$nat_env_factor[i],n),
                             #exp_env_cont = rep(genphenenv_df$exp_env_cont[i],n),
                             exp_env_cat = rep(genphenenv_df$exp_env_cat[i],n),
                             #exp_env_factor = rep(genphenenv_df$exp_env_factor[i],n),
                             phen_n = rep(n,n),
                             phen_data = dat)
    newdat = rbind(newdat_temp,newdat)
  }
  
  # Standardize data
  phen_mean = mean(newdat$phen_data) 
  phen_sd = sd(newdat$phen_data) 
  newdat$phen_corrected = ((newdat$phen_data-phen_mean)/phen_sd)
    
  # Model Comparison
  test_temp_a = lm(phen_corrected ~ exp_env_factor + gen_factor, data = newdat)
  test_temp_b = lm(phen_corrected ~ exp_env_factor * gen_factor, data = newdat)
  result = anova(test_temp_a,test_temp_b)
  
  # Model Outputs
  if(result[[2,6]] > 0.05){
    
  test_temp = lm(phen_corrected ~ exp_env_factor + gen_factor, data = newdat)
  
  # Model diagnostics
  res = residuals(test_temp)
  shap_wilkes = shapiro.test(res)
  is.normal <- NULL
  if(shap_wilkes[[2]] > 0.05){is.normal = "Yes"}else{is.normal = "No"}
  if(length(unique(genphenenv_df$exp_env_factor))>2){ # Wont work if only 2 environments
    test_nonlinear = lm(phen_corrected ~ (exp_env_factor^2) + gen_factor, data = genphenenv_df) #Polynomial 
  lin_test = lrtest(test_temp,test_nonlinear) # If p > 0.05, then data likely non-linear
  is.linear <- NULL
  if(lin_test[[2,5]] > 0.05){is.linear = "No"}else{is.linear = "Yes"}
  }else{is.linear <- "NA"}
  
  # Extract model outputs
  lm_result = "No_GxE"
  GxE_pval = result[[2,6]]
  E_R2 = summary(aov(test_temp))[[1]][1,2]/sum(summary(aov(test_temp))[[1]][,2])
  G_R2 = summary(aov(test_temp))[[1]][2,2]/sum(summary(aov(test_temp))[[1]][,2])
  GxE_R2 = NA

  mod_dat = data.frame()
  for(i in 1:length(test_temp[[1]])){
    id = names(test_temp[[1]][i]) 
    coef = test_temp[[1]][[i]]
    lwr_CI = confint(test_temp)[i,1]
    upr_CI = confint(test_temp)[i,2]
    pval = summary(test_temp)[[4]][i,4]
    mod_dat. = data.frame("id" = id,
                          "coef" = coef,
                          "lwr_CI" = lwr_CI,
                          "upr_CI" = upr_CI,
                          "pval" = pval)
    mod_dat = rbind(mod_dat,mod_dat.)
  }
  
  # Generate Matrices for Covariance and Permutations
  cov_temp <- expand.grid(gen_factor = unique(newdat$gen_factor),
                          exp_env_factor = unique(newdat$exp_env_factor))
  cov_temp$phen_predicted = predict(test_temp,cov_temp)
  }else{
    
  test_temp = lm(phen_corrected ~ exp_env_factor * gen_factor, data = newdat)
  
  # Model diagnostics
  res = residuals(test_temp)
  shap_wilkes = shapiro.test(res)
  is.normal <- NULL
  if(shap_wilkes[[2]] > 0.05){is.normal = "Yes"}else{is.normal = "No"}
  if(length(unique(genphenenv_df$exp_env_factor))>2){ # Wont work if only 2 environments
    test_nonlinear = lm(phen_corrected ~ (exp_env_factor^2) + gen_factor, data = genphenenv_df) #Polynomial 
  lin_test = lrtest(test_temp,test_nonlinear) # If p > 0.05, then data likely non-linear
  is.linear <- NULL
  if(lin_test[[2,5]] > 0.05){is.linear = "No"}else{is.linear = "Yes"}
  }else{is.linear <- "NA"}
  
  # Extract model outputs                
  lm_result = "Yes_GxE"
  GxE_pval = result[[2,6]]
  E_R2 = summary(aov(test_temp))[[1]][1,2]/sum(summary(aov(test_temp))[[1]][,2])
  G_R2 = summary(aov(test_temp))[[1]][2,2]/sum(summary(aov(test_temp))[[1]][,2])
  GxE_R2 = summary(aov(test_temp))[[1]][3,2]/sum(summary(aov(test_temp))[[1]][,2])
   
  mod_dat = data.frame()
  for(i in 1:length(test_temp[[1]])){
    id = names(test_temp[[1]][i]) 
    coef = test_temp[[1]][[i]]
    lwr_CI = confint(test_temp)[i,1]
    upr_CI = confint(test_temp)[i,2]
    pval = summary(test_temp)[[4]][i,4]
    mod_dat. = data.frame("id" = id,
                          "coef" = coef,
                          "lwr_CI" = lwr_CI,
                          "upr_CI" = upr_CI,
                          "pval" = pval)
    mod_dat = rbind(mod_dat,mod_dat.)
  }
  
  # Generate Matrices for Covariance and Permutations
  cov_temp <- expand.grid(gen_factor = unique(newdat$gen_factor),
                          exp_env_factor = unique(newdat$exp_env_factor))
  cov_temp$phen_predicted = predict(test_temp,cov_temp)
  }                 

 # Re-assign environmental variables
  cov_temp$nat_env_factor <- newdat$nat_env_factor[match(cov_temp$gen_factor,newdat$gen_factor)]

  # Covariance Emeans and Gmeans
  Cov_matrix = data.frame()
  
  # G_means
  G_mean_temp = data.frame()
  for(l in 1:length(unique(cov_temp$gen_factor))){
    G = unique(cov_temp$gen_factor)[l]
    G_temp = cov_temp[which(cov_temp$gen_factor == G),]
    G_mean = mean(unique(G_temp$phen_predicted))
    G_mean_temp1 = data.frame("G_mean" = G_mean,
                              "gen_factor" = G)
    G_mean_temp = rbind(G_mean_temp, G_mean_temp1)
}
                  
  # E_means
  E_mean_temp = data.frame()
                    
  for(m in 1:length(unique(cov_temp$nat_env_factor))){
    E = unique(cov_temp$nat_env_factor)[m]
    E_temp = cov_temp[which(cov_temp$nat_env_factor == E),]
    E_mean = mean(E_temp$phen_predicted)
    E_mean_temp1 = data.frame("E_mean" = E_mean,
                              "native_env" = E)
    E_mean_temp = rbind(E_mean_temp, E_mean_temp1)
    }
                    
    Cov_matrix = data.frame("gen" = G_mean_temp[,2],
                            "native_env" = as.factor(E_mean_temp[,2]),
                            "G_means" = G_mean_temp[,1],
                            "E_means" = E_mean_temp[,1])
    cov_est = cov(Cov_matrix$G_means,Cov_matrix$E_means) 
    
    model_specs = data.frame("Covariance_est" = cov_est,
                             "is.normal" = is.normal,
                             "is.linear" = is.linear,
                             "lm_result" = lm_result,
                             "GxE_pval" = GxE_pval,
                             "E_R2" = E_R2,
                             "G_R2" = G_R2,
                             "GxE_R2" = GxE_R2)

    return(list(mod_dat,Cov_matrix,model_specs))
}

testy = Cov_matrix_meanSE_categorical(faske)

## Sanity check

# Raw data
ggplot(faske,aes(x = exp_env_factor, y = phen_data, group = gen_factor, fill = gen_factor, colour = gen_factor)) + 
  geom_smooth(method = "gam") + theme_classic()

# new data after standardizing
ggplot(newdat,aes(x = exp_env_factor, y = phen_corrected, group = gen_factor, fill = gen_factor, colour = gen_factor)) + 
  geom_smooth(method = "gam") + theme_classic()

# Model predicted data from function
ggplot(cov_temp,aes(x = exp_env_factor, y = phen_predicted, group = gen_factor, fill = gen_factor, colour = gen_factor)) + 
  geom_smooth(method = "gam") + theme_classic()
```

** Covariance Matrices from Means/SE with Continuous data **

```{r}

## Covariance Matrix Function for data with only means and SE reported/continuous envs: 

Cov_matrix_meanSE_continuous <- function(genphenenv_df){

  # Generate data based on normal distribution of data with MEAN/STDEV/STDERROR
  newdat = data.frame()
for(i in 1:nrow(genphenenv_df)){
    n = genphenenv_df$phen_n[i]
    u = genphenenv_df$phen_data[i]
    SE = genphenenv_df$phen_mean_SE[i]
    dat = rnorm(n,u,SE)
    newdat_temp = data.frame(gen_factor = rep(genphenenv_df$gen_factor[i],n),
                             nat_env_mean = rep(genphenenv_df$nat_env_mean[i],n),
                             Native_env_cat = rep(genphenenv_df$Native_env_cat[i],n),
                             nat_env_factor = rep(genphenenv_df$nat_env_factor[i],n),
                             exp_env_cont = rep(genphenenv_df$exp_env_cont[i],n),
                             exp_env_cat = rep(genphenenv_df$exp_env_cat[i],n),
                             exp_env_factor = rep(genphenenv_df$exp_env_factor[i],n),
                             phen_n = rep(n,n),
                             phen_data = dat)
    newdat = rbind(newdat_temp,newdat)
  }
  
  # Standardize data
  phen_mean = mean(newdat$phen_data) 
  phen_sd = sd(newdat$phen_data) 
  nat_env_mean = mean(newdat$nat_env_mean) 
  nat_env_sd = sd(newdat$nat_env_mean)
  env_avg = mean(newdat$exp_env_cont) 
  env_std = sd(newdat$exp_env_cont)
  newdat$phen_corrected = ((newdat$phen_data-phen_mean)/phen_sd)
  newdat$env_corrected = ((newdat$exp_env_cont-env_avg)/env_std) 
  newdat$native_env_corrected = ((newdat$nat_env_mean-env_avg)/env_std) 
  
  # Model Comparison
  test_temp_a = lm(phen_corrected ~ env_corrected + gen_factor, data = newdat)
  test_temp_b = lm(phen_corrected ~ env_corrected * gen_factor, data = newdat)
  result = anova(test_temp_a,test_temp_b)
  
  # Model Outputs
  if(result[[2,6]] > 0.05){
    
  test_temp = lm(phen_corrected ~ env_corrected + gen_factor, data = newdat)
  
  # Model diagnostics
  res = residuals(test_temp)
  shap_wilkes = shapiro.test(res)
  is.normal <- NULL
  if(shap_wilkes[[2]] > 0.05){is.normal = "Yes"}else{is.normal = "No"}
  if(length(unique(genphenenv_df$env_corrected))>2){ # Wont work if only 2 environments
    test_nonlinear = lm(phen_corrected ~ (exp_env_factor^2) + gen_factor, data = genphenenv_df) #Polynomial 
  lin_test = lrtest(test_temp,test_nonlinear) # If p > 0.05, then data likely non-linear
  is.linear <- NULL
  if(lin_test[[2,5]] > 0.05){is.linear = "No"}else{is.linear = "Yes"}
  }else{is.linear <- "NA"}
  
  # Extract model outputs
  lm_result = "No_GxE"
  GxE_pval = result[[2,6]]
  E_R2 = summary(aov(test_temp))[[1]][1,2]/sum(summary(aov(test_temp))[[1]][,2])
  G_R2 = summary(aov(test_temp))[[1]][2,2]/sum(summary(aov(test_temp))[[1]][,2])
  GxE_R2 = NA

  mod_dat = data.frame()
  for(i in 1:length(test_temp[[1]])){
    id = names(test_temp[[1]][i]) 
    coef = test_temp[[1]][[i]]
    lwr_CI = confint(test_temp)[i,1]
    upr_CI = confint(test_temp)[i,2]
    pval = summary(test_temp)[[4]][i,4]
    mod_dat. = data.frame("id" = id,
                          "coef" = coef,
                          "lwr_CI" = lwr_CI,
                          "upr_CI" = upr_CI,
                          "pval" = pval)
    mod_dat = rbind(mod_dat,mod_dat.)
  }
  
  # Generate Matrices for Covariance and Permutations
  cov_temp <- data.frame(gen_factor = rep(genphenenv_df$gen_factor,
                                          each = length(seq(from = min(genphenenv_df$env_corrected), 
                                                            to = max(genphenenv_df$env_corrected),  by = 0.1))),
                         env_corrected = seq(from = min(genphenenv_df$env_corrected), 
                                             to = max(genphenenv_df$env_corrected), by = 0.1))
  cov_temp$phen_predicted = predict(test_temp,cov_temp)
  }else{
    
  test_temp = lm(phen_corrected ~ env_corrected * gen_factor, data = newdat)
  
  # Model diagnostics
  res = residuals(test_temp)
  shap_wilkes = shapiro.test(res)
  is.normal <- NULL
  if(shap_wilkes[[2]] > 0.05){is.normal = "Yes"}else{is.normal = "No"}
  if(length(unique(genphenenv_df$env_corrected))>2){ # Wont work if only 2 environments
    test_nonlinear = lm(phen_corrected ~ (exp_env_factor^2) + gen_factor, data = genphenenv_df) #Polynomial 
  lin_test = lrtest(test_temp,test_nonlinear) # If p > 0.05, then data likely non-linear
  is.linear <- NULL
  if(lin_test[[2,5]] > 0.05){is.linear = "No"}else{is.linear = "Yes"}
  }else{is.linear <- "NA"}
  
  # Extract model outputs                
  lm_result = "Yes_GxE"
  GxE_pval = result[[2,6]]
  E_R2 = summary(aov(test_temp))[[1]][1,2]/sum(summary(aov(test_temp))[[1]][,2])
  G_R2 = summary(aov(test_temp))[[1]][2,2]/sum(summary(aov(test_temp))[[1]][,2])
  GxE_R2 = summary(aov(test_temp))[[1]][3,2]/sum(summary(aov(test_temp))[[1]][,2])
   
  mod_dat = data.frame()
  for(i in 1:length(test_temp[[1]])){
    id = names(test_temp[[1]][i]) 
    coef = test_temp[[1]][[i]]
    lwr_CI = confint(test_temp)[i,1]
    upr_CI = confint(test_temp)[i,2]
    pval = summary(test_temp)[[4]][i,4]
    mod_dat. = data.frame("id" = id,
                          "coef" = coef,
                          "lwr_CI" = lwr_CI,
                          "upr_CI" = upr_CI,
                          "pval" = pval)
    mod_dat = rbind(mod_dat,mod_dat.)
  }
  
  # Generate Matrices for Covariance and Permutations
  cov_temp <- data.frame(gen_factor = rep(newdat$gen_factor,
                                          each = length(seq(from = min(newdat$env_corrected), 
                                                            to = max(newdat$env_corrected),  by = 0.1))),
                         env_corrected = seq(from = min(newdat$env_corrected), 
                                             to = max(newdat$env_corrected), by = 0.1))
  cov_temp$phen_predicted = predict(test_temp,cov_temp)
  }                 

  # Re-assign environmental variables to model predicted data 
  cov_temp$native_env_corrected <- newdat$native_env_corrected[match(cov_temp$gen_factor,newdat$gen_factor)]
  cov_temp$env_corrected <- round(cov_temp$env_corrected, digits = 1)
  cov_temp$native_env_corrected <- round(newdat$native_env_corrected[match(cov_temp$gen_factor,newdat$gen_factor)],digits =1)
  
  # Covariance Emeans and Gmeans
  Cov_matrix = data.frame()
  
  # G_means
  E_hat = round(mean(cov_temp$env_corrected),digits = 1)
  G_means = filter(cov_temp, env_corrected == E_hat)
                  
  # E_means
  E_mean_temp = data.frame()
                    
  for(m in 1:length(unique(cov_temp$native_env_corrected))){
    E = unique(cov_temp$native_env_corrected)[m]
    E_temp = cov_temp[which(cov_temp$env_corrected == E),]
    E_mean = mean(unique(E_temp$phen_predicted))
    E_mean_temp1 = data.frame("E_mean" = E_mean,
                              "env" = unique(E_temp$env))
    E_mean_temp = rbind(E_mean_temp, E_mean_temp1)
    }
                    
    Cov_matrix = data.frame("gen" = unique(cov_temp$gen),
                            "native_env" = as.factor(E_mean_temp[,2]),
                            "G_means" = unique(G_means$phen_predicted),
                            "E_means" = E_mean_temp[,1])
    cov_est = cov(Cov_matrix$G_means,Cov_matrix$E_means)
    
    model_specs = data.frame("Covariance_est" = cov_est,
                             "is.normal" = is.normal,
                             "is.linear" = is.linear,
                             "lm_result" = lm_result,
                             "GxE_pval" = GxE_pval,
                             "E_R2" = E_R2,
                             "G_R2" = G_R2,
                             "GxE_R2" = GxE_R2)

    return(list(mod_dat,Cov_matrix,model_specs))
}

testy <- Cov_matrix_meanSE_continuous(faske)

## Sanity check

# Raw data
ggplot(faske,aes(x = exp_env_cont, y = phen_data, 
                 group = gen_factor, fill = gen_factor, colour = gen_factor)) + 
  geom_smooth(method = "gam") + theme_classic()

# new data after standardizing
ggplot(newdat,aes(x = env_corrected, y = phen_corrected, 
                  group = gen_factor, fill = gen_factor, colour = gen_factor)) + 
  geom_smooth(method = "gam") + theme_classic()

# Model predicted data from function
ggplot(cov_temp,aes(x = env_corrected, y = phen_predicted, 
                    group = gen_factor, fill = gen_factor, colour = gen_factor)) + 
  geom_smooth(method = "gam") + theme_classic()

```

### Bootstrap Functions ###

```{r}

bootstap_categorical <- function(genphenenv_df){
    new_phen <- NULL
    shuffle_dat <- data.frame()
    
    for (j in 1:nlevels(genphenenv_df$gen_factor)){
      for (k in 1:nlevels(genphenenv_df$exp_env_factor)){
        G = unique(genphenenv_df$gen_factor)[j]
        E = unique(genphenenv_df$exp_env_factor)[k]
        cond_G <- filter(genphenenv_df, gen_factor == G)
        cond_E <- filter(cond_G, exp_env_factor == E)

      new_phen <- sample(cond_E$phen_data, size=nrow(cond_E), replace=TRUE)
      
      shuffle_dat_temp <- data.frame(gen_factor = cond_E$gen_factor,
                                     exp_env_factor = cond_E$exp_env_factor,
                                     Native_env_cat = cond_E$Native_env_cat,
                                     nat_env_factor = cond_E$nat_env_factor,
                                     phen_data = new_phen)
      shuffle_dat <- rbind(shuffle_dat, shuffle_dat_temp)
      }
    }
    shuffle_cov_temp = Cov_matrix_categorical(shuffle_dat)
    return(list(shuffle_cov_temp[[3]][[1]]))
}

bootstap_continuous <- function(genphenenv_df){
    new_phen <- NULL
    shuffle_dat <- data.frame()
    
    for (j in 1:nlevels(genphenenv_df$gen_factor)){
      for (k in 1:nlevels(genphenenv_df$exp_env_factor)){
        G = unique(genphenenv_df$gen_factor)[j]
        E = unique(genphenenv_df$exp_env_factor)[k]
        cond_G <- filter(genphenenv_df, gen_factor == G)
        cond_E <- filter(cond_G, exp_env_factor == E)

      new_phen <- sample(cond_E$phen_data, size=nrow(cond_E), replace=TRUE)
      
      shuffle_dat_temp <- data.frame(gen_factor = cond_E$gen_factor,
                                     Native_env_cont = cond_E$Native_env_cont,
                                     nat_env_mean = cond_E$nat_env_mean,
                                     nat_env_factor = cond_E$nat_env_factor,
                                     exp_env_factor = cond_E$exp_env_factor,
                                     exp_env_cont = cond_E$exp_env_cont,
                                     phen_data = new_phen)
      shuffle_dat <- rbind(shuffle_dat, shuffle_dat_temp)
    }
    }
    
    shuffle_cov_temp = Cov_matrix_continuous(shuffle_dat)
    return(list(shuffle_cov_temp[[3]][[1]]))
}

bootstap_continuous(lampei)
bootstap_categorical(gordon)

```

### Permutation Functions ###

```{r}

permutation_categorical <- function(genphenenv_df){
  
  null_temp <- NULL
  perm_dat = data.frame()
  
  null_temp <- sample(genphenenv_df$phen_data, size=nrow(genphenenv_df), replace=FALSE)
      
  perm_dat <- data.frame("gen_factor" = genphenenv_df$gen_factor,
                         "exp_env_factor" = genphenenv_df$exp_env_factor,
                         "Native_env_cat" = genphenenv_df$Native_env_cat,
                         "nat_env_factor" = genphenenv_df$nat_env_factor,
                         "phen_data" = null_temp)

  perm_cov_temp = Cov_matrix_categorical(perm_dat)
  return(list(perm_cov_temp[[3]][[1]]))
}

permutation_continuous <- function(genphenenv_df){
  
  null_temp <- NULL
  perm_dat = data.frame()

  null_temp <- sample(genphenenv_df$phen_data, size=nrow(genphenenv_df), replace=FALSE)
      
  perm_dat <- data.frame("gen_factor" = genphenenv_df$gen_factor,
                         "nat_env_mean" = genphenenv_df$nat_env_mean,
                         "exp_env_factor" = genphenenv_df$exp_env_factor,
                         "exp_env_cont" = genphenenv_df$exp_env_cont,
                         "phen_data" = null_temp)

  perm_cov_temp = Cov_matrix_continuous(perm_dat)
  return(list(perm_cov_temp[[3]][[1]]))
}

permutation_categorical(gordon)
permutation_continuous(lampei)
```

```{r}

Categorical_data <- function(genphenenv_df){
  
  iterations = 50
  
  ## Covariance estimate based on original data
  truecov = Cov_matrix_categorical(genphenenv_df)
  
  ## Magnitude of GxE
  GxE_R2 = truecov[[3]]["GxE_R2"][[1]]
  is.GxE = truecov[[3]]["lm_result"][[1]]
  GxE_pval = truecov[[3]]["GxE_pval"][[1]]

  ## Bootstrapped means and confidence intervals
  bootdat = replicate(iterations, bootstap_categorical(genphenenv_df), simplify=TRUE) 
  cov_CI = quantile(unlist(bootdat), probs=c(0.025, 0.975), type=1) # Confidence intervals around bootstrap covariance
  cov_avg = mean(as.numeric(unlist(bootdat))) # Mean should be similar to truecov
  
  ## Permutation 
  permdat <- replicate(iterations, permutation_categorical(genphenenv_df), simplify=TRUE) 
  
  ## Generate null distribution
  alpha = 0.05
  nulldist_lwrCI = quantile(unlist(permdat), alpha/2)
  nulldist_uprCI = quantile(unlist(permdat), 1-alpha/2)
                    
  is.sig = NA
  if( (truecov[[3]][[1]] < nulldist_lwrCI[[1]]) | (truecov[[3]][[1]] > nulldist_uprCI[[1]]) ) {is.sig = "yes"}else{is.sig = "no"}
  
  ## Generate P-value
  obs = unlist(truecov[[3]][[1]])
  new_dat = unlist(permdat)
  
  ptemp = (rank(c(obs,new_dat))[1])/(iterations+1) 
  p_value = NULL
  if(ptemp < 0.5){p_value = ptemp}else{p_value = (1-ptemp)}
  
  ## Output
  results = data.frame()
  return(results = data.frame("StudyID" = unique(genphenenv_df$Study_ID_phenotype),
                              "true cov" = truecov[[3]][[1]], 
                              "Low_CI" = cov_CI[1], 
                              "Hi_CI" = cov_CI[2], 
                              "Bootstrapped_Mean_cov" = cov_avg,
                              "NullDist_Low_CI" = nulldist_lwrCI,
                              "NullDist_Upr_CI" = nulldist_uprCI,
                              "covariance_p_value" = p_value,
                              "is.cov.sig" = is.sig,
                              "GxE_R2" = GxE_R2,
                              "is.GxE.sig" = is.GxE,
                              "GxE_pval" = GxE_pval)) 
}

results = Categorical_data(gordon)

```

```{r}
str(genphenenv_df)

Continuous_data <- function(genphenenv_df){
  
  iterations = 50
  
  ## Covariance estimate based on original data
  truecov = Cov_matrix_continuous(genphenenv_df)
  
  ## Magnitude of GxE
  GxE_R2 = truecov[[3]]["GxE_R2"][[1]]
  is.GxE = truecov[[3]]["lm_result"][[1]]
  GxE_pval = truecov[[3]]["GxE_pval"][[1]]

  ## Bootstrapped means and confidence intervals
  bootdat = replicate(iterations, bootstap_continuous(genphenenv_df), simplify=TRUE) 
  cov_CI = quantile(unlist(bootdat), probs=c(0.025, 0.975), type=1) # Confidence intervals around bootstrap covariance
  cov_avg = mean(as.numeric(unlist(bootdat))) # Mean should be similar to truecov
  
  ## Permutation 
  permdat <- replicate(iterations, permutation_continuous(genphenenv_df), simplify=TRUE) 
  
  ## Null Distribution
  alpha = 0.05
  nulldist_lwrCI = quantile(unlist(permdat), alpha/2)
  nulldist_uprCI = quantile(unlist(permdat), 1-alpha/2)
                    
  is.sig = NA # May want to correct for multiple testing
  if( (truecov[[3]][[1]] < nulldist_lwrCI[[1]]) | (truecov[[3]][[1]] > nulldist_uprCI[[1]]) ) {is.sig = "yes"}else{is.sig = "no"}
  
  ## Generate P-value
  obs = unlist(truecov[[3]][[1]])
  new_dat = unlist(permdat)
  
  ptemp = (rank(c(obs,new_dat))[1])/(iterations+1) 
  p_value = NULL
  if(ptemp < 0.5){p_value = ptemp}else{p_value = (1-ptemp)}
  
  ## Output
  results = data.frame()
  return(results = data.frame("StudyID" = unique(genphenenv_df$Study_ID_phenotype),
                              "true cov" = truecov[[3]][[1]], 
                              "Low_CI" = cov_CI[1], 
                              "Hi_CI" = cov_CI[2], 
                              "Bootstrapped_Mean_cov" = cov_avg,
                              "NullDist_Low_CI" = nulldist_lwrCI,
                              "NullDist_Upr_CI" = nulldist_uprCI,
                              "covariance_p_value" = p_value,
                              "is.cov.sig" = is.sig,
                              "GxE_R2" = GxE_R2,
                              "is.GxE.sig" = is.GxE,
                              "GxE_pval" = GxE_pval)) 
}

testy = Continuous_data(lampei)

```
### Power Function ###

To estimate power, we will use the simulated data to determine what effect sizes and replication is needed to have sufficient power to gain reliable results. 
```{r}

Power_function <- function(simdat){
 
   powerdat = data.frame()
  for(i in 1:length(unique(simdat$reps))){
    rep = unique(simdat$reps)[i]
    repdat = filter(simdat, reps == rep)
    for(j in 1:length(unique(repdat$std.dev))){
      sdev = unique(simdat$std.dev)[j]
      repdat2 = filter(repdat, std.dev == sdev)
      for(k in 1:length(unique(repdat2$effect.size))){
        effsize = unique(repdat2$effect.size)[k]
        repdat3 = filter(repdat2, effect.size == effsize)
        
        powerdat. = data.frame("reps" = unique(repdat3$reps),
                              "std.dev" = unique(repdat3$std.dev),
                                "effect.size" = unique(repdat3$effect.size),
                                "numer" = sum(repdat3$overunder),
                                "denom" = nrow(repdat3))
        powerdat = rbind(powerdat,powerdat.)
      }
    }
  }

powerdat$power = (powerdat$numer/powerdat$denom) 
  
}

```



** Old Code **
```{r}

# Resampling from each : dat_temp is data file with G, E, and phen 
  
bootshuffle_sim <- function(dat_temp){ 
    raw_dat2 = split(dat_temp,dat_temp$gen)
    boot_df = data.frame()
    
    for(n in 1:length(raw_dat2)){
      boot_temp = raw_dat2[[n]][sample(nrow(raw_dat2[[n]]), size = nrow(raw_dat2[[n]]),replace = TRUE),]
      boot_df = rbind(boot_df,boot_temp)
    }
    return(boot_df)
    }


permshuffle <- function(dat_temp){ 
    raw_dat3 = split(dat_temp,dat_temp$gen)
    perm_df = data.frame()
    
  for(m in 1:length(raw_dat2)){
      perm_temp = raw_dat3[[m]][sample(nrow(raw_dat3[[m]]), size = nrow(raw_dat3[[m]]),replace = FALSE),]
      perm_df = rbind(perm_df,phen_temp)
  }
  return(perm_df)
  }
  
permdat = permshuffle(dat_temp)
bootdat = bootshuffle(dat_temp)
  

test <- Cov_matrix(bootdat)
    
                  

# Permutation Hypothesis testing
(rank(c(obs,new_dat))[1])/(length(new_dat)+1) # outside distribution (p = 0.0). Greater than 0.5, 1-value. Less than, keep. Probability of observing by chance
}


 perm_val = (rank(c(unlist(cov_avg),(unlist(permdat[])))))/(length(permdat)+1) #Check this
  (pvalue <- perm_val/(iterations + 1))
   #(pvalue <- sum(abs(results) >= abs(cor.obs))/(nperms + 1))
```

